use std::num::NonZeroI64;

use common_utils::{errors, ext_traits::Encode, pii};
use masking::{PeekInterface, Secret};
use router_derive::Setter;
use time::PrimitiveDateTime;
use utoipa::ToSchema;

use crate::{enums as api_enums, refunds};

#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum PaymentOp {
    Create,
    Update,
    Confirm,
}

#[derive(Default, Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]
#[serde(deny_unknown_fields)]
pub struct PaymentsRequest {
    /// Unique identifier for the payment. This ensures impotency for multiple payments
    /// that have been done by a single merchant. This field is auto generated and is returned in the API response.
    #[schema(
        value_type = Option<String>,
        min_length = 30,
        max_length = 30,
        example = "pay_mbabizu24mvu3mela5njyhpit4"
    )]
    #[serde(default, deserialize_with = "payment_id_type::deserialize_option")]
    pub payment_id: Option<PaymentIdType>,
    /// This is an identifier for the merchant account. This is inferred from the API key
    /// provided during the request
    #[schema(max_length = 255, example = "merchant_1668273825")]
    pub merchant_id: Option<String>,
    /// The payment amount. Amount for the payment in lowest denomination of the currency. (i.e) in cents for USD denomination, in paisa for INR denomination etc.,
    #[schema(value_type = Option<u64>, example = 6540)]
    #[serde(default, deserialize_with = "amount::deserialize_option")]
    pub amount: Option<Amount>,
    /// This allows the merchant to manually select a connector with which the payment can go through
    #[schema(value_type = Option<Connector>, max_length = 255, example = "stripe")]
    pub connector: Option<api_enums::Connector>,
    /// The currency of the payment request can be specified here
    #[schema(value_type = Option<Currency>, example = "USD")]
    pub currency: Option<api_enums::Currency>,
    /// This is the instruction for capture/ debit the money from the users' card. On the other hand authorization refers to blocking the amount on the users' payment method.
    #[schema(value_type = Option<CaptureMethod>, example = "PaymentProcessor")]
    pub capture_method: Option<api_enums::CaptureMethod>,
    /// The Amount to be captured/ debited from the users payment method. It shall be in lowest denomination of the currency. (i.e) in cents for USD denomination, in paisa for INR denomination etc.,
    /// If not provided, the default amount_to_capture will be the payment amount.
    #[schema(example = 6540)]
    pub amount_to_capture: Option<i64>,
    /// A timestamp (ISO 8601 code) that determines when the payment should be captured.
    /// Providing this field will automatically set `capture` to true
    #[schema(example = "2022-09-10T10:11:12Z")]
    #[serde(default, with = "common_utils::custom_serde::iso8601::option")]
    pub capture_on: Option<PrimitiveDateTime>,
    /// Whether to confirm the payment (if applicable)
    #[schema(default = false, example = true)]
    pub confirm: Option<bool>,
    /// The identifier for the customer object. If not provided the customer ID will be autogenerated.
    #[schema(max_length = 255, example = "cus_y3oqhf46pyzuxjbcn2giaqnb44")]
    pub customer_id: Option<String>,
    /// description: The customer's email address
    #[schema(max_length = 255, value_type = Option<String>, example = "johntest@test.com")]
    pub email: Option<Secret<String, pii::Email>>,
    /// description: The customer's name
    #[schema(value_type = Option<String>, max_length = 255, example = "John Test")]
    pub name: Option<Secret<String>>,
    /// The customer's phone number
    #[schema(value_type = Option<String>, max_length = 255, example = "3141592653")]
    pub phone: Option<Secret<String>>,
    /// The country code for the customer phone number
    #[schema(max_length = 255, example = "+1")]
    pub phone_country_code: Option<String>,
    /// Set to true to indicate that the customer is not in your checkout flow during this payment, and therefore is unable to authenticate. This parameter is intended for scenarios where you collect card details and charge them later. This parameter can only be used with `confirm: true`.
    #[schema(example = true)]
    pub off_session: Option<bool>,
    /// A description of the payment
    #[schema(example = "It's my first payment request")]
    pub description: Option<String>,
    /// The URL to redirect after the completion of the operation
    #[schema(example = "https://hyperswitch.io")]
    pub return_url: Option<String>,
    /// Indicates that you intend to make future payments with this Payment’s payment method. Providing this parameter will attach the payment method to the Customer, if present, after the Payment is confirmed and any required actions from the user are complete.
    #[schema(value_type = Option<FutureUsage>, example = "off_session")]
    pub setup_future_usage: Option<api_enums::FutureUsage>,
    /// The transaction authentication can be set to undergo payer authentication.
    #[schema(value_type = Option<AuthenticationType>, example = "no_three_ds", default = "three_ds")]
    pub authentication_type: Option<api_enums::AuthenticationType>,
    /// The payment method information provided for making a payment
    #[schema(example = "bank_transfer")]
    pub payment_method_data: Option<PaymentMethod>,
    /// The payment method that is to be used
    #[schema(value_type = Option<PaymentMethodType>, example = "bank_transfer")]
    pub payment_method: Option<api_enums::PaymentMethodType>,
    /// Provide a reference to a stored payment method
    #[schema(example = "187282ab-40ef-47a9-9206-5099ba31e432")]
    pub payment_token: Option<String>,
    /// This is used when payment is to be confirmed and the card is not saved
    #[schema(value_type = Option<String>)]
    pub card_cvc: Option<Secret<String>>,
    /// The shipping address for the payment
    pub shipping: Option<Address>,
    /// The billing address for the payment
    pub billing: Option<Address>,
    /// For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    #[schema(max_length = 255, example = "Juspay Router")]
    pub statement_descriptor_name: Option<String>,
    /// Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
    #[schema(max_length = 255, example = "Payment for shoes purchase")]
    pub statement_descriptor_suffix: Option<String>,
    /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.
    pub metadata: Option<Metadata>,
    /// It's a token used for client side verification.
    #[schema(example = "pay_U42c409qyHwOkWo3vK60_secret_el9ksDkiB8hi6j9N78yo")]
    pub client_secret: Option<String>,
    /// Provide mandate information for creating a mandate
    pub mandate_data: Option<MandateData>,
    /// A unique identifier to link the payment to a mandate, can be use instead of payment_method_data
    #[schema(max_length = 255, example = "mandate_iwer89rnjef349dni3")]
    pub mandate_id: Option<String>,
    /// Additional details required by 3DS 2.0
    #[schema(value_type = Option<Object>, example = r#"{
        "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36",
        "accept_header": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
        "language": "nl-NL",
        "color_depth": 24,
        "screen_height": 723,
        "screen_width": 1536,
        "time_zone": 0,
        "java_enabled": true,
        "java_script_enabled":true
    }"#)]
    pub browser_info: Option<serde_json::Value>,
    /// Payment Issuser for the current payment
    #[schema(value_type = Option<PaymentIssuer>, example = "klarna")]
    pub payment_issuer: Option<api_enums::PaymentIssuer>,
    /// Payment Experience, works in tandem with payment_issuer
    #[schema(value_type = Option<PaymentExperience>, example = "redirect_to_url")]
    pub payment_experience: Option<api_enums::PaymentExperience>,
}

#[derive(Default, Debug, serde::Deserialize, serde::Serialize, Clone, Copy, PartialEq, Eq)]
pub enum Amount {
    Value(NonZeroI64),
    #[default]
    Zero,
}

impl From<Amount> for i64 {
    fn from(amount: Amount) -> Self {
        match amount {
            Amount::Value(val) => val.get(),
            Amount::Zero => 0,
        }
    }
}

impl From<i64> for Amount {
    fn from(val: i64) -> Self {
        NonZeroI64::new(val).map_or(Self::Zero, Amount::Value)
    }
}

#[derive(Default, Debug, serde::Deserialize, serde::Serialize, Clone)]
#[serde(deny_unknown_fields)]
pub struct PaymentsRedirectRequest {
    pub payment_id: String,
    pub merchant_id: String,
    pub connector: String,
    pub param: String,
}

#[derive(Default, Debug, serde::Deserialize, serde::Serialize, Clone)]
#[serde(deny_unknown_fields)]
pub struct VerifyRequest {
    // The merchant_id is generated through api key
    // and is later passed in the struct
    pub merchant_id: Option<String>,
    pub customer_id: Option<String>,
    pub email: Option<Secret<String, pii::Email>>,
    pub name: Option<Secret<String>>,
    pub phone: Option<Secret<String>>,
    pub phone_country_code: Option<String>,
    pub payment_method: Option<api_enums::PaymentMethodType>,
    pub payment_method_data: Option<PaymentMethod>,
    pub payment_token: Option<String>,
    pub mandate_data: Option<MandateData>,
    pub setup_future_usage: Option<api_enums::FutureUsage>,
    pub off_session: Option<bool>,
    pub client_secret: Option<String>,
}

impl From<PaymentsRequest> for VerifyRequest {
    fn from(item: PaymentsRequest) -> Self {
        Self {
            client_secret: item.client_secret,
            merchant_id: item.merchant_id,
            customer_id: item.customer_id,
            email: item.email,
            name: item.name,
            phone: item.phone,
            phone_country_code: item.phone_country_code,
            payment_method: item.payment_method,
            payment_method_data: item.payment_method_data,
            payment_token: item.payment_token,
            mandate_data: item.mandate_data,
            setup_future_usage: item.setup_future_usage,
            off_session: item.off_session,
        }
    }
}

#[derive(Clone)]
pub enum MandateTxnType {
    NewMandateTxn,
    RecurringMandateTxn,
}

#[derive(Default, Eq, PartialEq, Debug, serde::Deserialize, serde::Serialize, Clone)]
pub struct MandateIds {
    pub mandate_id: String,
    pub connector_mandate_id: Option<String>,
}

impl MandateIds {
    pub fn new(mandate_id: String) -> Self {
        Self {
            mandate_id,
            connector_mandate_id: None,
        }
    }
}

#[derive(Default, Eq, PartialEq, Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]
#[serde(deny_unknown_fields)]
pub struct MandateData {
    /// A concent from the customer to store the payment method
    pub customer_acceptance: CustomerAcceptance,
    /// A way to select the type of mandate used
    pub mandate_type: MandateType,
}

#[derive(Clone, Eq, PartialEq, Copy, Debug, Default, serde::Serialize, serde::Deserialize)]
pub struct SingleUseMandate {
    pub amount: i64,
    pub currency: api_enums::Currency,
}

#[derive(
    Clone, Eq, PartialEq, Copy, Debug, Default, ToSchema, serde::Serialize, serde::Deserialize,
)]
pub struct MandateAmountData {
    /// The maximum amount to be debited for the mandate transaction
    #[schema(example = 6540)]
    pub amount: i64,
    /// The currency for the transaction
    #[schema(value_type = Currency, example = "USD")]
    pub currency: api_enums::Currency,
}

#[derive(Eq, PartialEq, Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]
#[serde(rename_all = "snake_case")]
pub enum MandateType {
    /// If the mandate should only be valid for 1 off-session use
    SingleUse(MandateAmountData),
    /// If the mandate should be valid for multiple debits
    MultiUse(Option<MandateAmountData>),
}

impl Default for MandateType {
    fn default() -> Self {
        Self::MultiUse(None)
    }
}

#[derive(Default, Eq, PartialEq, Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]
#[serde(deny_unknown_fields)]
pub struct CustomerAcceptance {
    /// Type of acceptance provided by the
    #[schema(example = "online")]
    pub acceptance_type: AcceptanceType,
    /// Specifying when the customer acceptance was provided
    #[schema(example = "2022-09-10T10:11:12Z")]
    #[serde(default, with = "common_utils::custom_serde::iso8601::option")]
    pub accepted_at: Option<PrimitiveDateTime>,
    /// Information required for online mandate generation
    pub online: Option<OnlineMandate>,
}

#[derive(Default, Debug, serde::Deserialize, serde::Serialize, PartialEq, Eq, Clone, ToSchema)]
#[serde(rename_all = "lowercase")]
pub enum AcceptanceType {
    Online,
    #[default]
    Offline,
}

#[derive(Default, Eq, PartialEq, Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]
#[serde(deny_unknown_fields)]
pub struct OnlineMandate {
    /// Ip address of the customer machine from which the mandate was created
    #[schema(value_type = String, example = "123.32.25.123")]
    pub ip_address: Secret<String, pii::IpAddress>,
    /// The user-agent of the customer's browser
    pub user_agent: String,
}

#[derive(Default, Eq, PartialEq, Clone, Debug, serde::Deserialize, serde::Serialize, ToSchema)]
pub struct Card {
    /// The card number
    #[schema(value_type = String, example = "4242424242424242")]
    pub card_number: Secret<String, pii::CardNumber>,
    /// The card's expiry month
    #[schema(value_type = String, example = "24")]
    pub card_exp_month: Secret<String>,
    /// The card's expiry year
    #[schema(value_type = String, example = "24")]
    pub card_exp_year: Secret<String>,
    /// The card holder's name
    #[schema(value_type = String, example = "John Test")]
    pub card_holder_name: Secret<String>,
    /// The CVC number for the card
    #[schema(value_type = String, example = "242")]
    pub card_cvc: Secret<String>,
}

#[derive(Eq, PartialEq, Clone, Debug, serde::Deserialize, serde::Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub enum KlarnaIssuer {
    Klarna,
}

#[derive(Eq, PartialEq, Clone, Debug, serde::Deserialize, serde::Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub enum AffirmIssuer {
    Affirm,
}

#[derive(Eq, PartialEq, Clone, Debug, serde::Deserialize, serde::Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub enum AfterpayClearpayIssuer {
    AfterpayClearpay,
}

#[derive(Eq, PartialEq, Clone, Debug, serde::Deserialize, serde::Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub enum PayLaterData {
    /// For KlarnaRedirect as PayLater Option
    KlarnaRedirect {
        /// The billing email
        #[schema(value_type = String)]
        billing_email: Secret<String, pii::Email>,
        // The billing country code
        billing_country: String,
    },
    /// For Klarna Sdk as PayLater Option
    KlarnaSdk {
        /// The token for the sdk workflow
        token: String,
    },
    /// For Affirm redirect as PayLater Option
    AffirmRedirect {},
    /// For AfterpayClearpay redirect as PayLater Option
    AfterpayClearpayRedirect {
        /// The billing email
        #[schema(value_type = String)]
        billing_email: Secret<String, pii::Email>,
        /// The billing name
        #[schema(value_type = String)]
        billing_name: Secret<String>,
    },
}

#[derive(Debug, Clone, Eq, PartialEq, Default, serde::Deserialize, serde::Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub enum PaymentMethod {
    Card(Card),
    #[default]
    BankTransfer,
    Wallet(WalletData),
    PayLater(PayLaterData),
    Paypal,
}

#[derive(Eq, PartialEq, Clone, Debug, serde::Deserialize, serde::Serialize, ToSchema)]
pub struct WalletData {
    /// The issuer of the wallet
    #[schema(value_type = WalletIssuer)]
    pub issuer_name: api_enums::WalletIssuer,
    /// Token generated for the wallet
    pub token: Option<String>,
}

#[derive(Eq, PartialEq, Clone, Debug, serde::Serialize)]
pub struct CardResponse {
    last4: String,
    exp_month: String,
    exp_year: String,
}

#[derive(Debug, Clone, Eq, PartialEq, serde::Serialize)]
pub enum PaymentMethodDataResponse {
    #[serde(rename = "card")]
    Card(CardResponse),
    #[serde(rename(deserialize = "bank_transfer"))]
    BankTransfer,
    Wallet(WalletData),
    PayLater(PayLaterData),
    Paypal,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize, ToSchema)]
pub enum PaymentIdType {
    /// The identifier for payment intent
    PaymentIntentId(String),
    /// The identifier for connector transaction
    ConnectorTransactionId(String),
    /// The identifier for payment attempt
    PaymentAttemptId(String),
}

impl Default for PaymentIdType {
    fn default() -> Self {
        Self::PaymentIntentId(Default::default())
    }
}

//#[derive(Debug, serde::Deserialize, serde::Serialize)]
//#[serde(untagged)]
//pub enum enums::CaptureMethod {
//Automatic,
//Manual,
//}

//impl Default for enums::CaptureMethod {
//fn default() -> Self {
//enums::CaptureMethod::Manual
//}
//}

#[derive(
    Default,
    Clone,
    Debug,
    Eq,
    PartialEq,
    ToSchema,
    serde::Deserialize,
    serde::Serialize,
    frunk::LabelledGeneric,
)]
#[serde(deny_unknown_fields)]
pub struct Address {
    /// Provide the address details
    pub address: Option<AddressDetails>,

    pub phone: Option<PhoneDetails>,
}

// used by customers also, could be moved outside
#[derive(
    Clone,
    Default,
    Debug,
    Eq,
    serde::Deserialize,
    serde::Serialize,
    PartialEq,
    ToSchema,
    frunk::LabelledGeneric,
)]
#[serde(deny_unknown_fields)]
pub struct AddressDetails {
    /// The address city
    #[schema(max_length = 50, example = "New York")]
    pub city: Option<String>,

    /// The two-letter ISO country code for the address
    #[schema(max_length = 2, min_length = 2, example = "US")]
    pub country: Option<String>,

    /// The first line of the address
    #[schema(value_type = Option<String>, max_length = 200, example = "123, King Street")]
    pub line1: Option<Secret<String>>,

    /// The second line of the address
    #[schema(value_type = Option<String>, max_length = 50, example = "Powelson Avenue")]
    pub line2: Option<Secret<String>>,

    /// The third line of the address
    #[schema(value_type = Option<String>, max_length = 50, example = "Bridgewater")]
    pub line3: Option<Secret<String>>,

    /// The zip/postal code for the address
    #[schema(value_type = Option<String>, max_length = 50, example = "08807")]
    pub zip: Option<Secret<String>>,

    /// The address state
    #[schema(value_type = Option<String>, example = "New York")]
    pub state: Option<Secret<String>>,

    /// The first name for the address
    #[schema(value_type = Option<String>, max_length = 255, example = "John")]
    pub first_name: Option<Secret<String>>,

    /// The last name for the address
    #[schema(value_type = Option<String>, max_length = 255, example = "Doe")]
    pub last_name: Option<Secret<String>>,
}

#[derive(
    Debug,
    Clone,
    Default,
    Eq,
    PartialEq,
    ToSchema,
    serde::Deserialize,
    serde::Serialize,
    frunk::LabelledGeneric,
)]
pub struct PhoneDetails {
    /// The contact number
    #[schema(value_type = Option<String>, example = "9999999999")]
    pub number: Option<Secret<String>>,
    /// The country code attached to the number
    #[schema(example = "+1")]
    pub country_code: Option<String>,
}

#[derive(Debug, Clone, Default, Eq, PartialEq, serde::Deserialize, ToSchema)]
pub struct PaymentsCaptureRequest {
    /// The unique identifier for the payment
    pub payment_id: Option<String>,
    /// The unique identifier for the merchant
    pub merchant_id: Option<String>,
    /// The Amount to be captured/ debited from the user's payment method.
    pub amount_to_capture: Option<i64>,
    /// Decider to refund the uncaptured amount
    pub refund_uncaptured_amount: Option<bool>,
    /// Provides information about a card payment that customers see on their statements.
    pub statement_descriptor_suffix: Option<String>,
    /// Concatenated with the statement descriptor suffix that’s set on the account to form the complete statement descriptor.
    pub statement_descriptor_prefix: Option<String>,
}

#[derive(Default, Clone, Debug, Eq, PartialEq, serde::Serialize)]
pub struct UrlDetails {
    pub url: String,
    pub method: String,
}
#[derive(Default, Clone, Debug, Eq, PartialEq, serde::Serialize)]
pub struct AuthenticationForStartResponse {
    pub authentication: UrlDetails,
}
#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub enum NextActionType {
    RedirectToUrl,
    DisplayQrCode,
    InvokeSdkClient,
    TriggerApi,
}
#[derive(Clone, Debug, Eq, PartialEq, serde::Serialize, ToSchema)]
pub struct NextAction {
    /// Specifying the action type to be performed next
    #[serde(rename = "type")]
    pub next_action_type: NextActionType,
    /// Contains the url for redirection flow
    #[schema(example = "https://router.juspay.io/redirect/fakushdfjlksdfasklhdfj")]
    pub redirect_to_url: Option<String>,
}

#[derive(Setter, Clone, Default, Debug, Eq, PartialEq, serde::Serialize, ToSchema)]
pub struct PaymentsResponse {
    /// Unique identifier for the payment. This ensures impotency for multiple payments
    /// that have been done by a single merchant.
    #[schema(
        min_length = 30,
        max_length = 30,
        example = "pay_mbabizu24mvu3mela5njyhpit4"
    )]
    pub payment_id: Option<String>,
    /// This is an identifier for the merchant account. This is inferred from the API key
    /// provided during the request
    #[schema(max_length = 255, example = "merchant_1668273825")]
    pub merchant_id: Option<String>,
    /// The status of the current payment that was made
    #[schema(value_type = IntentStatus, example = "failed", default = "requires_confirmation")]
    pub status: api_enums::IntentStatus,
    /// The payment amount. Amount for the payment in lowest denomination of the currency. (i.e) in cents for USD denomination, in paisa for INR denomination etc.,
    #[schema(example = 100)]
    pub amount: i64,
    /// The maximum amount that could be captured from the payment
    #[schema(minimum = 100, example = 6540)]
    pub amount_capturable: Option<i64>,
    /// The amount which is already captured from the payment
    #[schema(minimum = 100, example = 6540)]
    pub amount_received: Option<i64>,
    /// The connector used for the payment
    #[schema(example = "stripe")]
    pub connector: Option<String>,
    /// It's a token used for client side verification.
    #[schema(value_type = Option<String>, example = "pay_U42c409qyHwOkWo3vK60_secret_el9ksDkiB8hi6j9N78yo")]
    pub client_secret: Option<Secret<String>>,
    /// Time when the payment was created
    #[schema(example = "2022-09-10T10:11:12Z")]
    #[serde(with = "common_utils::custom_serde::iso8601::option")]
    pub created: Option<PrimitiveDateTime>,
    /// The currency of the amount of the payment
    #[schema(value_type = Currency, example = "USD")]
    pub currency: String,
    /// The identifier for the customer object. If not provided the customer ID will be autogenerated.
    #[schema(max_length = 255, example = "cus_y3oqhf46pyzuxjbcn2giaqnb44")]
    pub customer_id: Option<String>,
    /// A description of the payment
    #[schema(example = "It's my first payment request")]
    pub description: Option<String>,
    /// List of refund that happened on this intent
    #[schema(value_type = Option<Vec<RefundResponse>>)]
    pub refunds: Option<Vec<refunds::RefundResponse>>,
    /// A unique identifier to link the payment to a mandate, can be use instead of payment_method_data
    #[schema(max_length = 255, example = "mandate_iwer89rnjef349dni3")]
    pub mandate_id: Option<String>,
    /// Provided mandate information for creating a mandate
    pub mandate_data: Option<MandateData>,
    /// Indicates that you intend to make future payments with this Payment’s payment method. Providing this parameter will attach the payment method to the Customer, if present, after the Payment is confirmed and any required actions from the user are complete.
    #[schema(value_type = Option<FutureUsage>, example = "off_session")]
    pub setup_future_usage: Option<api_enums::FutureUsage>,
    /// Set to true to indicate that the customer is not in your checkout flow during this payment, and therefore is unable to authenticate. This parameter is intended for scenarios where you collect card details and charge them later. This parameter can only be used with confirm=true.
    #[schema(example = true)]
    pub off_session: Option<bool>,
    /// A timestamp (ISO 8601 code) that determines when the payment should be captured.
    /// Providing this field will automatically set `capture` to true
    #[schema(example = "2022-09-10T10:11:12Z")]
    #[serde(with = "common_utils::custom_serde::iso8601::option")]
    pub capture_on: Option<PrimitiveDateTime>,
    /// This is the instruction for capture/ debit the money from the users' card. On the other hand authorization refers to blocking the amount on the users' payment method.
    #[schema(value_type = Option<CaptureMethod>, example = "PaymentProcessor")]
    pub capture_method: Option<api_enums::CaptureMethod>,
    /// The payment method that is to be used
    #[schema(value_type = PaymentMethodType, example = "bank_transfer")]
    #[auth_based]
    pub payment_method: Option<api_enums::PaymentMethodType>,
    /// The payment method information provided for making a payment
    #[schema(value_type = Option<PaymentMethod>, example = "bank_transfer")]
    #[auth_based]
    pub payment_method_data: Option<PaymentMethodDataResponse>,
    /// Provide a reference to a stored payment method
    #[schema(example = "187282ab-40ef-47a9-9206-5099ba31e432")]
    pub payment_token: Option<String>,
    /// The shipping address for the payment
    pub shipping: Option<Address>,
    /// The billing address for the payment
    pub billing: Option<Address>,
    /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.
    #[schema(value_type = Option<Object>)]
    pub metadata: Option<serde_json::Value>,
    /// description: The customer's email address
    #[schema(max_length = 255, value_type = Option<String>, example = "johntest@test.com")]
    pub email: Option<Secret<String, pii::Email>>,
    /// description: The customer's name
    #[schema(value_type = Option<String>, max_length = 255, example = "John Test")]
    pub name: Option<Secret<String>>,
    /// The customer's phone number
    #[schema(value_type = Option<String>, max_length = 255, example = "3141592653")]
    pub phone: Option<Secret<String>>,
    /// The URL to redirect after the completion of the operation
    #[schema(example = "https://hyperswitch.io")]
    pub return_url: Option<String>,
    /// The transaction authentication can be set to undergo payer authentication. By default, the authentication will be marked as NO_THREE_DS
    #[schema(value_type = Option<AuthenticationType>, example = "no_three_ds", default = "three_ds")]
    pub authentication_type: Option<api_enums::AuthenticationType>,
    /// For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    #[schema(max_length = 255, example = "Juspay Router")]
    pub statement_descriptor_name: Option<String>,
    /// Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 255 characters for the concatenated descriptor.
    #[schema(max_length = 255, example = "Payment for shoes purchase")]
    pub statement_descriptor_suffix: Option<String>,
    /// Additional information required for redirection
    pub next_action: Option<NextAction>,
    /// If the payment was cancelled the reason provided here
    pub cancellation_reason: Option<String>,
    /// If there was an error while calling the connectors the code is received here
    #[schema(example = "E0001")]
    pub error_code: Option<String>,
    /// If there was an error while calling the connector the error message is received here
    #[schema(example = "Failed while verifying the card")]
    pub error_message: Option<String>,
}

#[derive(Clone, Debug, serde::Deserialize, ToSchema)]
#[serde(deny_unknown_fields)]
pub struct PaymentListConstraints {
    /// The identifier for customer
    pub customer_id: Option<String>,
    /// A cursor for use in pagination, fetch the next list after some object
    pub starting_after: Option<String>,
    /// A cursor for use in pagination, fetch the previous list before some object
    pub ending_before: Option<String>,
    /// limit on the number of objects to return
    #[serde(default = "default_limit")]
    pub limit: i64,
    /// The time at which payment is created
    #[serde(default, with = "common_utils::custom_serde::iso8601::option")]
    pub created: Option<PrimitiveDateTime>,
    /// Time less than the payment created time
    #[serde(default, with = "common_utils::custom_serde::iso8601::option")]
    #[serde(rename = "created.lt")]
    pub created_lt: Option<PrimitiveDateTime>,
    /// Time greater than the payment created time
    #[serde(default, with = "common_utils::custom_serde::iso8601::option")]
    #[serde(rename = "created.gt")]
    pub created_gt: Option<PrimitiveDateTime>,
    /// Time less than or equals to the payment created time
    #[serde(default, with = "common_utils::custom_serde::iso8601::option")]
    #[serde(rename = "created.lte")]
    pub created_lte: Option<PrimitiveDateTime>,
    /// Time greater than or equals to the payment created time
    #[serde(default, with = "common_utils::custom_serde::iso8601::option")]
    #[serde(rename = "created.gte")]
    pub created_gte: Option<PrimitiveDateTime>,
}

#[derive(Clone, Debug, serde::Serialize, ToSchema)]
pub struct PaymentListResponse {
    /// The number of payments included in the list
    pub size: usize,
    // The list of payments response objects
    pub data: Vec<PaymentsResponse>,
}

#[derive(Setter, Clone, Default, Debug, Eq, PartialEq, serde::Serialize)]
pub struct VerifyResponse {
    pub verify_id: Option<String>,
    pub merchant_id: Option<String>,
    // pub status: enums::VerifyStatus,
    pub client_secret: Option<Secret<String>>,
    pub customer_id: Option<String>,
    pub email: Option<Secret<String, pii::Email>>,
    pub name: Option<Secret<String>>,
    pub phone: Option<Secret<String>>,
    pub mandate_id: Option<String>,
    #[auth_based]
    pub payment_method: Option<api_enums::PaymentMethodType>,
    #[auth_based]
    pub payment_method_data: Option<PaymentMethodDataResponse>,
    pub payment_token: Option<String>,
    pub error_code: Option<String>,
    pub error_message: Option<String>,
}

fn default_limit() -> i64 {
    10
}

#[derive(Default, Debug, serde::Deserialize, serde::Serialize)]
pub struct PaymentsRedirectionResponse {
    pub redirect_url: String,
}

pub struct MandateValidationFields {
    pub mandate_id: Option<String>,
    pub confirm: Option<bool>,
    pub customer_id: Option<String>,
    pub mandate_data: Option<MandateData>,
    pub setup_future_usage: Option<api_enums::FutureUsage>,
    pub off_session: Option<bool>,
}

impl From<&PaymentsRequest> for MandateValidationFields {
    fn from(req: &PaymentsRequest) -> Self {
        Self {
            mandate_id: req.mandate_id.clone(),
            confirm: req.confirm,
            customer_id: req.customer_id.clone(),
            mandate_data: req.mandate_data.clone(),
            setup_future_usage: req.setup_future_usage,
            off_session: req.off_session,
        }
    }
}

impl From<&VerifyRequest> for MandateValidationFields {
    fn from(req: &VerifyRequest) -> Self {
        Self {
            mandate_id: None,
            confirm: Some(true),
            customer_id: req.customer_id.clone(),
            mandate_data: req.mandate_data.clone(),
            off_session: req.off_session,
            setup_future_usage: req.setup_future_usage,
        }
    }
}

impl TryFrom<PaymentsRequest> for PaymentsResponse {
    type Error = error_stack::Report<errors::ParsingError>;
    fn try_from(item: PaymentsRequest) -> Result<Self, Self::Error> {
        let payment_id = match item.payment_id {
            Some(PaymentIdType::PaymentIntentId(id)) => Some(id),
            _ => None,
        };
        let metadata = item
            .metadata
            .as_ref()
            .map(Encode::<Metadata>::encode_to_value)
            .transpose()?;
        Ok(Self {
            payment_id,
            merchant_id: item.merchant_id,
            setup_future_usage: item.setup_future_usage,
            off_session: item.off_session,
            shipping: item.shipping,
            billing: item.billing,
            metadata,
            capture_method: item.capture_method,
            payment_method: item.payment_method,
            capture_on: item.capture_on,
            payment_method_data: item
                .payment_method_data
                .map(PaymentMethodDataResponse::from),
            email: item.email,
            name: item.name,
            phone: item.phone,
            payment_token: item.payment_token,
            return_url: item.return_url,
            authentication_type: item.authentication_type,
            statement_descriptor_name: item.statement_descriptor_name,
            statement_descriptor_suffix: item.statement_descriptor_suffix,
            mandate_data: item.mandate_data,
            ..Default::default()
        })
    }
}

impl From<VerifyRequest> for VerifyResponse {
    fn from(item: VerifyRequest) -> Self {
        Self {
            merchant_id: item.merchant_id,
            customer_id: item.customer_id,
            email: item.email,
            name: item.name,
            phone: item.phone,
            payment_method: item.payment_method,
            payment_method_data: item
                .payment_method_data
                .map(PaymentMethodDataResponse::from),
            payment_token: item.payment_token,
            ..Default::default()
        }
    }
}

impl From<PaymentsStartRequest> for PaymentsResponse {
    fn from(item: PaymentsStartRequest) -> Self {
        Self {
            payment_id: Some(item.payment_id),
            merchant_id: Some(item.merchant_id),
            ..Default::default()
        }
    }
}

impl From<PaymentsSessionRequest> for PaymentsResponse {
    fn from(item: PaymentsSessionRequest) -> Self {
        Self {
            payment_id: Some(item.payment_id),
            ..Default::default()
        }
    }
}

impl From<PaymentsSessionRequest> for PaymentsSessionResponse {
    fn from(item: PaymentsSessionRequest) -> Self {
        let client_secret: Secret<String, pii::ClientSecret> = Secret::new(item.client_secret);
        Self {
            session_token: vec![],
            payment_id: item.payment_id,
            client_secret,
        }
    }
}

impl From<PaymentsStartRequest> for PaymentsRequest {
    fn from(item: PaymentsStartRequest) -> Self {
        Self {
            payment_id: Some(PaymentIdType::PaymentIntentId(item.payment_id)),
            merchant_id: Some(item.merchant_id),
            ..Default::default()
        }
    }
}

impl From<PaymentsRetrieveRequest> for PaymentsResponse {
    // After removing the request from the payments_to_payments_response this will no longer be needed
    fn from(item: PaymentsRetrieveRequest) -> Self {
        let payment_id = match item.resource_id {
            PaymentIdType::PaymentIntentId(id) => Some(id),
            _ => None,
        };

        Self {
            payment_id,
            merchant_id: item.merchant_id,
            ..Default::default()
        }
    }
}

impl From<PaymentsCancelRequest> for PaymentsResponse {
    fn from(item: PaymentsCancelRequest) -> Self {
        Self {
            payment_id: Some(item.payment_id),
            cancellation_reason: item.cancellation_reason,
            ..Default::default()
        }
    }
}

impl From<PaymentsCaptureRequest> for PaymentsResponse {
    // After removing the request from the payments_to_payments_response this will no longer be needed
    fn from(item: PaymentsCaptureRequest) -> Self {
        Self {
            payment_id: item.payment_id,
            amount_received: item.amount_to_capture,
            ..Self::default()
        }
    }
}

impl From<Card> for CardResponse {
    fn from(card: Card) -> Self {
        let card_number_length = card.card_number.peek().clone().len();
        Self {
            last4: card.card_number.peek().clone()[card_number_length - 4..card_number_length]
                .to_string(),
            exp_month: card.card_exp_month.peek().clone(),
            exp_year: card.card_exp_year.peek().clone(),
        }
    }
}

impl From<PaymentMethod> for PaymentMethodDataResponse {
    fn from(payment_method_data: PaymentMethod) -> Self {
        match payment_method_data {
            PaymentMethod::Card(card) => Self::Card(CardResponse::from(card)),
            PaymentMethod::BankTransfer => Self::BankTransfer,
            PaymentMethod::PayLater(pay_later_data) => Self::PayLater(pay_later_data),
            PaymentMethod::Wallet(wallet_data) => Self::Wallet(wallet_data),
            PaymentMethod::Paypal => Self::Paypal,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize)]
pub struct PgRedirectResponse {
    pub payment_id: String,
    pub status: api_enums::IntentStatus,
    pub gateway_id: String,
    pub customer_id: Option<String>,
    pub amount: Option<i64>,
}

#[derive(Debug, serde::Serialize, PartialEq, Eq, serde::Deserialize)]
pub struct RedirectionResponse {
    pub return_url: String,
    pub params: Vec<(String, String)>,
    pub return_url_with_query_params: String,
    pub http_method: String,
    pub headers: Vec<(String, String)>,
}

#[derive(Debug, serde::Deserialize)]
pub struct PaymentsResponseForm {
    pub transaction_id: String,
    // pub transaction_reference_id: String,
    pub merchant_id: String,
    pub order_id: String,
}

#[derive(Default, Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]
pub struct PaymentsRetrieveRequest {
    /// The type of ID (ex: payment intent id, payment attempt id or connector txn id)
    pub resource_id: PaymentIdType,
    /// The identifier for the Merchant Account.
    pub merchant_id: Option<String>,
    /// Decider to enable or disable the connector call for retrieve request
    pub force_sync: bool,
    /// The parameters passed to a retrieve request
    pub param: Option<String>,
    /// The name of the connector
    pub connector: Option<String>,
}

#[derive(Debug, Default, Eq, PartialEq, serde::Deserialize, serde::Serialize, Clone, ToSchema)]
pub struct OrderDetails {
    /// Name of the product that is being purchased
    #[schema(max_length = 255, example = "shirt")]
    pub product_name: String,
    /// The quantity of the product to be purchased
    #[schema(example = 1)]
    pub quantity: u16,
}

#[derive(Default, Debug, Eq, PartialEq, serde::Deserialize, serde::Serialize, Clone, ToSchema)]
pub struct Metadata {
    /// Information about the product and quantity for specific connectors. (e.g. Klarna)
    pub order_details: Option<OrderDetails>,
    /// Any other metadata that is to be provided
    #[schema(value_type = Object, example = r#"{ "city": "NY", "unit": "245" }"#)]
    #[serde(flatten)]
    pub data: serde_json::Value,
}

#[derive(Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]
pub struct PaymentsSessionRequest {
    /// The identifier for the payment
    pub payment_id: String,
    /// This is a token which expires after 15 minutes, used from the client to authenticate and create sessions from the SDK
    pub client_secret: String,
    /// The list of the supported wallets
    #[schema(value_type = Vec<SupportedWallets>)]
    pub wallets: Vec<api_enums::SupportedWallets>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]
pub struct GpayAllowedMethodsParameters {
    /// The list of allowed auth methods (ex: 3DS, No3DS, PAN_ONLY etc)
    pub allowed_auth_methods: Vec<String>,
    /// The list of allowed card networks (ex: AMEX,JCB etc)
    pub allowed_card_networks: Vec<String>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]
pub struct GpayTokenParameters {
    /// The name of the connector
    pub gateway: String,
    /// The merchant ID registered in the connector associated
    pub gateway_merchant_id: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]
pub struct GpayTokenizationSpecification {
    /// The token specification type(ex: PAYMENT_GATEWAY)
    #[serde(rename = "type")]
    pub token_specification_type: String,
    /// The parameters for the token specification Google Pay
    pub parameters: GpayTokenParameters,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]
pub struct GpayAllowedPaymentMethods {
    /// The type of payment method
    #[serde(rename = "type")]
    pub payment_method_type: String,
    /// The parameters Google Pay requires
    pub parameters: GpayAllowedMethodsParameters,
    /// The tokenization specification for Google Pay
    pub tokenization_specification: GpayTokenizationSpecification,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]
pub struct GpayTransactionInfo {
    /// The country code
    pub country_code: String,
    /// The currency code
    pub currency_code: String,
    /// The total price status (ex: 'FINAL')
    pub total_price_status: String,
    /// The total price
    pub total_price: i64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, ToSchema)]
pub struct GpayMerchantInfo {
    /// The name of the merchant
    pub merchant_name: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct GpayMetaData {
    pub merchant_info: GpayMerchantInfo,
    pub allowed_payment_methods: Vec<GpayAllowedPaymentMethods>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct GpaySessionTokenData {
    #[serde(rename = "gpay")]
    pub data: GpayMetaData,
}

#[derive(Debug, Clone, serde::Serialize, ToSchema)]
#[serde(tag = "wallet_name")]
#[serde(rename_all = "lowercase")]
pub enum SessionToken {
    /// The session response structure for Google Pay
    Gpay {
        /// The merchant info
        merchant_info: GpayMerchantInfo,
        /// List of the allowed payment meythods
        allowed_payment_methods: Vec<GpayAllowedPaymentMethods>,
        /// The transaction info Google Pay requires
        transaction_info: GpayTransactionInfo,
    },
    /// The session response structure for Klarna
    Klarna {
        /// The session token for Klarna
        session_token: String,
        /// The identifier for the session
        session_id: String,
    },
    /// The session response structure for PayPal
    Paypal {
        /// The session token for PayPal
        session_token: String,
    },
    /// The session response structure for Apple Pay
    Applepay {
        /// Timestamp at which session is requested
        epoch_timestamp: u64,
        /// Timestamp at which session expires
        expires_at: u64,
        /// The identifier for the merchant session
        merchant_session_identifier: String,
        /// Applepay generates unique ID (UUID) value
        nonce: String,
        /// The identifier for the merchant
        merchant_identifier: String,
        /// The domain name of the merchant which is registered in Apple Pay
        domain_name: String,
        /// The name to be displayed on Apple Pay button
        display_name: String,
        /// A string which represents the properties of a payment
        signature: String,
        /// The identifier for the operational analytics
        operational_analytics_identifier: String,
        /// The number of retries to get the session response
        retries: u8,
        /// The identifier for the connector transaction
        psp_id: String,
    },
}

#[derive(Default, Debug, serde::Serialize, Clone, ToSchema)]
pub struct PaymentsSessionResponse {
    /// The identifier for the payment
    pub payment_id: String,
    /// This is a token which expires after 15 minutes, used from the client to authenticate and create sessions from the SDK
    #[schema(value_type = String)]
    pub client_secret: Secret<String, pii::ClientSecret>,
    /// The list of session token object
    pub session_token: Vec<SessionToken>,
}

#[derive(Default, Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]
pub struct PaymentRetrieveBody {
    /// The identifier for the Merchant Account.
    pub merchant_id: Option<String>,
    /// Decider to enable or disable the connector call for retrieve request
    pub force_sync: Option<bool>,
}
#[derive(Default, Debug, serde::Deserialize, serde::Serialize, Clone, ToSchema)]
pub struct PaymentsCancelRequest {
    /// The identifier for the payment
    #[serde(skip)]
    pub payment_id: String,
    /// The reason for the payment cancel
    pub cancellation_reason: Option<String>,
}

#[derive(Default, Debug, serde::Deserialize, serde::Serialize, ToSchema)]
pub struct PaymentsStartRequest {
    /// Unique identifier for the payment. This ensures impotency for multiple payments
    /// that have been done by a single merchant. This field is auto generated and is returned in the API response.
    pub payment_id: String,
    /// The identifier for the Merchant Account.
    pub merchant_id: String,
    /// The identifier for the payment transaction
    pub attempt_id: String,
}

mod payment_id_type {
    use std::fmt;

    use serde::{
        de::{self, Visitor},
        Deserializer,
    };

    use super::PaymentIdType;

    struct PaymentIdVisitor;
    struct OptionalPaymentIdVisitor;

    impl<'de> Visitor<'de> for PaymentIdVisitor {
        type Value = PaymentIdType;

        fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
            formatter.write_str("payment id")
        }

        fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            Ok(PaymentIdType::PaymentIntentId(value.to_string()))
        }
    }

    impl<'de> Visitor<'de> for OptionalPaymentIdVisitor {
        type Value = Option<PaymentIdType>;

        fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
            formatter.write_str("payment id")
        }

        fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
        where
            D: Deserializer<'de>,
        {
            deserializer.deserialize_any(PaymentIdVisitor).map(Some)
        }

        fn visit_none<E>(self) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            Ok(None)
        }

        fn visit_unit<E>(self) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            Ok(None)
        }
    }

    #[allow(dead_code)]
    pub(crate) fn deserialize<'a, D>(deserializer: D) -> Result<PaymentIdType, D::Error>
    where
        D: Deserializer<'a>,
    {
        deserializer.deserialize_any(PaymentIdVisitor)
    }

    pub(crate) fn deserialize_option<'a, D>(
        deserializer: D,
    ) -> Result<Option<PaymentIdType>, D::Error>
    where
        D: Deserializer<'a>,
    {
        deserializer.deserialize_option(OptionalPaymentIdVisitor)
    }
}

mod amount {
    use serde::de;

    use super::Amount;
    struct AmountVisitor;
    struct OptionalAmountVisitor;

    // This is defined to provide guarded deserialization of amount
    // which itself handles zero and non-zero values internally
    impl<'de> de::Visitor<'de> for AmountVisitor {
        type Value = Amount;

        fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(formatter, "amount as integer")
        }

        fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            let v = i64::try_from(v).map_err(|_| {
                E::custom(format!(
                    "invalid value `{v}`, expected an integer between 0 and {}",
                    i64::MAX
                ))
            })?;
            self.visit_i64(v)
        }

        fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            if v.is_negative() {
                return Err(E::custom(format!(
                    "invalid value `{v}`, expected a positive integer"
                )));
            }
            Ok(Amount::from(v))
        }
    }

    impl<'de> de::Visitor<'de> for OptionalAmountVisitor {
        type Value = Option<Amount>;

        fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(formatter, "option of amount (as integer)")
        }

        fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_i64(AmountVisitor).map(Some)
        }

        fn visit_none<E>(self) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            Ok(None)
        }
    }

    #[allow(dead_code)]
    pub(crate) fn deserialize<'de, D>(deserializer: D) -> Result<Amount, D::Error>
    where
        D: de::Deserializer<'de>,
    {
        deserializer.deserialize_any(AmountVisitor)
    }
    pub(crate) fn deserialize_option<'de, D>(deserializer: D) -> Result<Option<Amount>, D::Error>
    where
        D: de::Deserializer<'de>,
    {
        deserializer.deserialize_option(OptionalAmountVisitor)
    }
}

#[cfg(test)]
mod tests {
    #![allow(clippy::unwrap_used)]
    use super::*;

    #[test]
    fn test_mandate_type() {
        let mandate_type = MandateType::default();
        assert_eq!(
            serde_json::to_string(&mandate_type).unwrap(),
            r#"{"multi_use":null}"#
        )
    }
}
