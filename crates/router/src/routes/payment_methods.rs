use actix_web::{web, HttpRequest, HttpResponse};
use common_utils::{consts::TOKEN_TTL, errors::CustomResult};
use diesel_models::enums::IntentStatus;
use error_stack::ResultExt;
use router_env::{instrument, logger, tracing, Flow};
use time::PrimitiveDateTime;

use super::app::AppState;
use crate::{
    core::{api_locking, errors, payment_methods::cards},
    services::{api, authentication as auth},
    types::{
        api::payment_methods::{self, PaymentMethodId},
        storage::payment_method::PaymentTokenData,
    },
    utils::Encode,
};

#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsCreate))]
/// This method is used to create a payment method asynchronously. It takes the AppSate, HttpRequest, and a JSON payload containing the payment method information as input. It then uses the `api::server_wrap` function to wrap the process of adding a payment method, and returns the HttpResponse once the process is complete.
pub async fn create_payment_method_api(
    state: web::Data<AppState>,
    req: HttpRequest,
    json_payload: web::Json<payment_methods::PaymentMethodCreate>,
) -> HttpResponse {
    let flow = Flow::PaymentMethodsCreate;
    Box::pin(api::server_wrap(
        flow,
        state,
        &req,
        json_payload.into_inner(),
        |state, auth, req| async move {
            Box::pin(cards::add_payment_method(
                state,
                req,
                &auth.merchant_account,
                &auth.key_store,
            ))
            .await
        },
        &auth::ApiKeyAuth,
        api_locking::LockAction::NotApplicable,
    ))
    .await
}

#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsList))]
/// Handles the API endpoint for listing payment methods. It extracts the client secret from the request
/// and uses it to authenticate the request. It then calls the `list_payment_methods` function to retrieve 
/// the list of payment methods associated with the merchant account and key store provided in the authentication 
/// details. The function returns a wrapped response using the `server_wrap` function.
pub async fn list_payment_method_api(
    state: web::Data<AppState>,
    req: HttpRequest,
    json_payload: web::Query<payment_methods::PaymentMethodListRequest>,
) -> HttpResponse {
    let flow = Flow::PaymentMethodsList;
    let payload = json_payload.into_inner();
    let (auth, _) = match auth::check_client_secret_and_get_auth(req.headers(), &payload) {
        Ok((auth, _auth_flow)) => (auth, _auth_flow),
        Err(e) => return api::log_and_return_error_response(e),
    };

    Box::pin(api::server_wrap(
        flow,
        state,
        &req,
        payload,
        |state, auth, req| {
            cards::list_payment_methods(state, auth.merchant_account, auth.key_store, req)
        },
        &*auth,
        api_locking::LockAction::NotApplicable,
    ))
    .await
}
/// List payment methods for a Customer
///
/// To filter and list the applicable payment methods for a particular Customer ID
#[utoipa::path(
    get,
    path = "/customers/{customer_id}/payment_methods",
    params (
        ("accepted_country" = Vec<String>, Query, description = "The two-letter ISO currency code"),
        ("accepted_currency" = Vec<Currency>, Path, description = "The three-letter ISO currency code"),
        ("minimum_amount" = i64, Query, description = "The minimum amount accepted for processing by the particular payment method."),
        ("maximum_amount" = i64, Query, description = "The maximum amount amount accepted for processing by the particular payment method."),
        ("recurring_payment_enabled" = bool, Query, description = "Indicates whether the payment method is eligible for recurring payments"),
        ("installment_payment_enabled" = bool, Query, description = "Indicates whether the payment method is eligible for installment payments"),
    ),
    responses(
        (status = 200, description = "Payment Methods retrieved", body = CustomerPaymentMethodsListResponse),
        (status = 400, description = "Invalid Data"),
        (status = 404, description = "Payment Methods does not exist in records")
    ),
    tag = "Payment Methods",
    operation_id = "List all Payment Methods for a Customer",
    security(("api_key" = []))
)]
#[instrument(skip_all, fields(flow = ?Flow::CustomerPaymentMethodsList))]
/// Handles the API endpoint for listing customer payment methods. 
/// Retrieves the customer ID and query payload from the request, and then wraps the
/// API call in a server wrapper, passing in the necessary parameters for fetching the 
/// customer's payment methods. Returns the HTTP response generated by the API call.
pub async fn list_customer_payment_method_api(
    state: web::Data<AppState>,
    customer_id: web::Path<(String,)>,
    req: HttpRequest,
    query_payload: web::Query<payment_methods::PaymentMethodListRequest>,
) -> HttpResponse {
    let flow = Flow::CustomerPaymentMethodsList;
    let payload = query_payload.into_inner();
    let customer_id = customer_id.into_inner().0;
    Box::pin(api::server_wrap(
        flow,
        state,
        &req,
        payload,
        |state, auth, req| {
            cards::do_list_customer_pm_fetch_customer_if_not_passed(
                state,
                auth.merchant_account,
                auth.key_store,
                Some(req),
                Some(&customer_id),
            )
        },
        &auth::ApiKeyAuth,
        api_locking::LockAction::NotApplicable,
    ))
    .await
}
/// List payment methods for a Customer
///
/// To filter and list the applicable payment methods for a particular Customer ID
#[utoipa::path(
    get,
    path = "/customers/payment_methods",
    params (
        ("client-secret" = String, Path, description = "A secret known only to your application and the authorization server"),
        ("accepted_country" = Vec<String>, Query, description = "The two-letter ISO currency code"),
        ("accepted_currency" = Vec<Currency>, Path, description = "The three-letter ISO currency code"),
        ("minimum_amount" = i64, Query, description = "The minimum amount accepted for processing by the particular payment method."),
        ("maximum_amount" = i64, Query, description = "The maximum amount amount accepted for processing by the particular payment method."),
        ("recurring_payment_enabled" = bool, Query, description = "Indicates whether the payment method is eligible for recurring payments"),
        ("installment_payment_enabled" = bool, Query, description = "Indicates whether the payment method is eligible for installment payments"),
    ),
    responses(
        (status = 200, description = "Payment Methods retrieved for customer tied to its respective client-secret passed in the param", body = CustomerPaymentMethodsListResponse),
        (status = 400, description = "Invalid Data"),
        (status = 404, description = "Payment Methods does not exist in records")
    ),
    tag = "Payment Methods",
    operation_id = "List all Payment Methods for a Customer",
    security(("publishable_key" = []))
)]
#[instrument(skip_all, fields(flow = ?Flow::CustomerPaymentMethodsList))]
/// This method is used to handle the endpoint for listing customer payment methods. It takes the current application state, the request object, and the query payload as input parameters. It checks the client secret and authorization, then performs the necessary action to fetch and list the customer's payment methods. The method returns a response as an asynchronous HTTP response.
pub async fn list_customer_payment_method_api_client(
    state: web::Data<AppState>,
    req: HttpRequest,
    query_payload: web::Query<payment_methods::PaymentMethodListRequest>,
) -> HttpResponse {
    let flow = Flow::CustomerPaymentMethodsList;
    let payload = query_payload.into_inner();
    let (auth, _) = match auth::check_client_secret_and_get_auth(req.headers(), &payload) {
        Ok((auth, _auth_flow)) => (auth, _auth_flow),
        Err(e) => return api::log_and_return_error_response(e),
    };
    Box::pin(api::server_wrap(
        flow,
        state,
        &req,
        payload,
        |state, auth, req| {
            cards::do_list_customer_pm_fetch_customer_if_not_passed(
                state,
                auth.merchant_account,
                auth.key_store,
                Some(req),
                None,
            )
        },
        &*auth,
        api_locking::LockAction::NotApplicable,
    ))
    .await
}

#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsRetrieve))]
/// Retrieves a payment method using the provided payment method ID.
pub async fn payment_method_retrieve_api(
    state: web::Data<AppState>,
    req: HttpRequest,
    path: web::Path<String>,
) -> HttpResponse {
    let flow = Flow::PaymentMethodsRetrieve;
    let payload = web::Json(PaymentMethodId {
        payment_method_id: path.into_inner(),
    })
    .into_inner();

    Box::pin(api::server_wrap(
        flow,
        state,
        &req,
        payload,
        |state, auth, pm| cards::retrieve_payment_method(state, pm, auth.key_store),
        &auth::ApiKeyAuth,
        api_locking::LockAction::NotApplicable,
    ))
    .await
}

#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsUpdate))]
/// This method handles the update of a payment method for a customer. It takes in the Appstate, HttpRequest, path, and JSON payload, and then wraps the update operation in a server wrap function. The update operation calls the `update_customer_payment_method` function from the `cards` module, passing in the state, merchant account, payload, payment method id, and key store. Finally, it awaits the result of the server wrap function and returns the HttpResponse.
pub async fn payment_method_update_api(
    state: web::Data<AppState>,
    req: HttpRequest,
    path: web::Path<String>,
    json_payload: web::Json<payment_methods::PaymentMethodUpdate>,
) -> HttpResponse {
    let flow = Flow::PaymentMethodsUpdate;
    let payment_method_id = path.into_inner();

    Box::pin(api::server_wrap(
        flow,
        state,
        &req,
        json_payload.into_inner(),
        |state, auth, payload| {
            cards::update_customer_payment_method(
                state,
                auth.merchant_account,
                payload,
                &payment_method_id,
                auth.key_store,
            )
        },
        &auth::ApiKeyAuth,
        api_locking::LockAction::NotApplicable,
    ))
    .await
}

#[instrument(skip_all, fields(flow = ?Flow::PaymentMethodsDelete))]
/// Handles the API endpoint for deleting a payment method. It takes the `AppState`, `HttpRequest`, and the `payment_method_id` as parameters and returns an `HttpResponse`. It creates a `Flow` of type `PaymentMethodsDelete` and a `PaymentMethodId` from the `payment_method_id` parameter. It then uses `api::server_wrap` to call the `cards::delete_payment_method` function with the appropriate parameters and returns the result as a boxed future.
pub async fn payment_method_delete_api(
    state: web::Data<AppState>,
    req: HttpRequest,
    payment_method_id: web::Path<(String,)>,
) -> HttpResponse {
    let flow = Flow::PaymentMethodsDelete;
    let pm = PaymentMethodId {
        payment_method_id: payment_method_id.into_inner().0,
    };
    Box::pin(api::server_wrap(
        flow,
        state,
        &req,
        pm,
        |state, auth, req| cards::delete_payment_method(state, auth.merchant_account, req),
        &auth::ApiKeyAuth,
        api_locking::LockAction::NotApplicable,
    ))
    .await
}
#[cfg(test)]
mod tests {
    #![allow(clippy::unwrap_used)]
    use api_models::payment_methods::PaymentMethodListRequest;

    use super::*;

    #[test]
        /// Parses a dummy data string into a `PaymentMethodListRequest` struct using `web::Query`, and then asserts that the `installment_payment_enabled` field is `Some(true)`.
    fn test_custom_list_deserialization() {
        let dummy_data = "amount=120&recurring_enabled=true&installment_payment_enabled=true";
        let de_query: web::Query<PaymentMethodListRequest> =
            web::Query::from_query(dummy_data).unwrap();
        let de_struct = de_query.into_inner();
        assert_eq!(de_struct.installment_payment_enabled, Some(true))
    }

    #[test]
        /// This method is used to test the deserialization of a custom list with multiple amounts in the query string.
    fn test_custom_list_deserialization_multi_amount() {
        let dummy_data = "amount=120&recurring_enabled=true&amount=1000";
        let de_query: Result<web::Query<PaymentMethodListRequest>, _> =
            web::Query::from_query(dummy_data);
        assert!(de_query.is_err())
    }
}

#[derive(Clone)]
pub struct ParentPaymentMethodToken {
    key_for_token: String,
}

impl ParentPaymentMethodToken {
        /// Creates a unique key for a given parent payment token and payment method combination.
    pub fn create_key_for_token(
            (parent_pm_token, payment_method): (&String, api_models::enums::PaymentMethod),
        ) -> Self {
            Self {
                key_for_token: format!(
                    "pm_token_{}_{}_hyperswitch",
                    parent_pm_token, payment_method
                ),
            }
        }
        /// Asynchronously inserts a payment token into the Redis store with an optional intent creation time,
    /// using the provided `intent_created_at` timestamp and `token` data. The method also requires access to the
    /// application state `state` in order to interact with the Redis store. Returns a `CustomResult` indicating
    /// success or an `ApiErrorResponse` in case of failure.
    pub async fn insert(
        &self,
        intent_created_at: Option<PrimitiveDateTime>,
        token: PaymentTokenData,
        state: &AppState,
    ) -> CustomResult<(), errors::ApiErrorResponse> {
        let token_json_str = Encode::<PaymentTokenData>::encode_to_string_of_json(&token)
            .change_context(errors::ApiErrorResponse::InternalServerError)
            .attach_printable("failed to serialize hyperswitch token to json")?;
        let redis_conn = state
            .store
            .get_redis_conn()
            .change_context(errors::ApiErrorResponse::InternalServerError)
            .attach_printable("Failed to get redis connection")?;
        let current_datetime_utc = common_utils::date_time::now();
        let time_elapsed = current_datetime_utc - intent_created_at.unwrap_or(current_datetime_utc);
        redis_conn
            .set_key_with_expiry(
                &self.key_for_token,
                token_json_str,
                TOKEN_TTL - time_elapsed.whole_seconds(),
            )
            .await
            .change_context(errors::StorageError::KVError)
            .change_context(errors::ApiErrorResponse::InternalServerError)
            .attach_printable("Failed to add token in redis")?;

        Ok(())
    }

        /// Determines whether the payment method token should be deleted based on the provided intent status.
    ///
    /// If the intent status is RequiresCustomerAction or RequiresMerchantAction, the payment method token should not be deleted.
    ///
    /// # Arguments
    ///
    /// * `status` - The intent status for the payment
    ///
    /// # Returns
    ///
    /// A boolean value indicating whether the payment method token should be deleted
    pub fn should_delete_payment_method_token(&self, status: IntentStatus) -> bool {
        ![
            IntentStatus::RequiresCustomerAction,
            IntentStatus::RequiresMerchantAction,
        ]
        .contains(&status)
    }

        /// Asynchronously deletes a key from the Redis store using the provided `state`. Returns a `CustomResult` indicating success or an `ApiErrorResponse` if an error occurs.
    pub async fn delete(&self, state: &AppState) -> CustomResult<(), errors::ApiErrorResponse> {
        let redis_conn = state
            .store
            .get_redis_conn()
            .change_context(errors::ApiErrorResponse::InternalServerError)
            .attach_printable("Failed to get redis connection")?;
        match redis_conn.delete_key(&self.key_for_token).await {
            Ok(_) => Ok(()),
            Err(err) => {
                {
                    logger::info!("Error while deleting redis key: {:?}", err)
                };
                Ok(())
            }
        }
    }
}
