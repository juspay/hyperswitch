/*
 * Hyperswitch - API Documentation
 *
 *  ## Get started  Hyperswitch provides a collection of APIs that enable you to process and manage payments. Our APIs accept and return JSON in the HTTP body, and return standard HTTP response codes.  You can consume the APIs directly using your favorite HTTP/REST library.  We have a testing environment referred to \"sandbox\", which you can setup to test API calls without affecting production data. Currently, our sandbox environment is live while our production environment is under development and will be available soon. You can sign up on our Dashboard to get API keys to access Hyperswitch API.  ### Environment  Use the following base URLs when making requests to the APIs:  | Environment   |  Base URL                          | |---------------|------------------------------------| | Sandbox       | <https://sandbox.hyperswitch.io>   | | Production    | <https://api.hyperswitch.io>       |  ## Authentication  When you sign up on our [dashboard](https://app.hyperswitch.io) and create a merchant account, you are given a secret key (also referred as api-key) and a publishable key. You may authenticate all API requests with Hyperswitch server by providing the appropriate key in the request Authorization header.  | Key             |  Description                                                                                  | |-----------------|-----------------------------------------------------------------------------------------------| | api-key         | Private key. Used to authenticate all API requests from your merchant server                  | | publishable key | Unique identifier for your account. Used to authenticate API requests from your app's client  |  Never share your secret api keys. Keep them guarded and secure. 
 *
 * The version of the OpenAPI document: 0.2.0
 * Contact: hyperswitch@juspay.in
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct PaymentsResponse {
    /// Unique identifier for the payment. This ensures idempotency for multiple payments that have been done by a single merchant.
    #[serde(rename = "payment_id", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub payment_id: Option<Option<String>>,
    /// This is an identifier for the merchant account. This is inferred from the API key provided during the request
    #[serde(rename = "merchant_id", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub merchant_id: Option<Option<String>>,
    #[serde(rename = "status")]
    pub status: crate::models::IntentStatus,
    /// The payment amount. Amount for the payment in lowest denomination of the currency. (i.e) in cents for USD denomination, in paisa for INR denomination etc.,
    #[serde(rename = "amount")]
    pub amount: i64,
    /// The maximum amount that could be captured from the payment
    #[serde(rename = "amount_capturable", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub amount_capturable: Option<Option<i64>>,
    /// The amount which is already captured from the payment
    #[serde(rename = "amount_received", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub amount_received: Option<Option<i64>>,
    /// The connector used for the payment
    #[serde(rename = "connector", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub connector: Option<Option<String>>,
    /// It's a token used for client side verification.
    #[serde(rename = "client_secret", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub client_secret: Option<Option<String>>,
    /// Time when the payment was created
    #[serde(rename = "created", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub created: Option<Option<String>>,
    #[serde(rename = "currency")]
    pub currency: crate::models::Currency,
    /// The identifier for the customer object. If not provided the customer ID will be autogenerated.
    #[serde(rename = "customer_id", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub customer_id: Option<Option<String>>,
    /// A description of the payment
    #[serde(rename = "description", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub description: Option<Option<String>>,
    /// List of refund that happened on this intent
    #[serde(rename = "refunds", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub refunds: Option<Option<Vec<crate::models::RefundResponse>>>,
    /// List of dispute that happened on this intent
    #[serde(rename = "disputes", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub disputes: Option<Option<Vec<crate::models::DisputeResponsePaymentsRetrieve>>>,
    /// A unique identifier to link the payment to a mandate, can be use instead of payment_method_data
    #[serde(rename = "mandate_id", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub mandate_id: Option<Option<String>>,
    #[serde(rename = "mandate_data", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub mandate_data: Option<Option<Box<crate::models::MandateData>>>,
    #[serde(rename = "setup_future_usage", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub setup_future_usage: Option<Option<crate::models::FutureUsage>>,
    /// Set to true to indicate that the customer is not in your checkout flow during this payment, and therefore is unable to authenticate. This parameter is intended for scenarios where you collect card details and charge them later. This parameter can only be used with confirm=true.
    #[serde(rename = "off_session", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub off_session: Option<Option<bool>>,
    /// A timestamp (ISO 8601 code) that determines when the payment should be captured. Providing this field will automatically set `capture` to true
    #[serde(rename = "capture_on", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub capture_on: Option<Option<String>>,
    #[serde(rename = "capture_method", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub capture_method: Option<Option<crate::models::CaptureMethod>>,
    #[serde(rename = "payment_method")]
    pub payment_method: crate::models::PaymentMethodType,
    #[serde(rename = "payment_method_data", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub payment_method_data: Option<Option<crate::models::PaymentMethod>>,
    /// Provide a reference to a stored payment method
    #[serde(rename = "payment_token", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub payment_token: Option<Option<String>>,
    #[serde(rename = "shipping", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub shipping: Option<Option<Box<crate::models::Address>>>,
    #[serde(rename = "billing", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub billing: Option<Option<Box<crate::models::Address>>>,
    /// Information about the product , quantity and amount for connectors. (e.g. Klarna)
    #[serde(rename = "order_details", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub order_details: Option<Option<Vec<crate::models::OrderDetailsWithAmount>>>,
    /// description: The customer's email address
    #[serde(rename = "email", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub email: Option<Option<String>>,
    /// description: The customer's name
    #[serde(rename = "name", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub name: Option<Option<String>>,
    /// The customer's phone number
    #[serde(rename = "phone", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub phone: Option<Option<String>>,
    /// The URL to redirect after the completion of the operation
    #[serde(rename = "return_url", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub return_url: Option<Option<String>>,
    #[serde(rename = "authentication_type", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub authentication_type: Option<Option<crate::models::AuthenticationType>>,
    /// For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
    #[serde(rename = "statement_descriptor_name", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub statement_descriptor_name: Option<Option<String>>,
    /// Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 255 characters for the concatenated descriptor.
    #[serde(rename = "statement_descriptor_suffix", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub statement_descriptor_suffix: Option<Option<String>>,
    #[serde(rename = "next_action", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub next_action: Option<Option<Box<crate::models::NextActionData>>>,
    /// If the payment was cancelled the reason provided here
    #[serde(rename = "cancellation_reason", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub cancellation_reason: Option<Option<String>>,
    /// If there was an error while calling the connectors the code is received here
    #[serde(rename = "error_code", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub error_code: Option<Option<String>>,
    /// If there was an error while calling the connector the error message is received here
    #[serde(rename = "error_message", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub error_message: Option<Option<String>>,
    #[serde(rename = "payment_experience", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub payment_experience: Option<Option<crate::models::PaymentExperience>>,
    #[serde(rename = "payment_method_type", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub payment_method_type: Option<Option<crate::models::PaymentMethodType>>,
    /// The connector used for this payment along with the country and business details
    #[serde(rename = "connector_label", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub connector_label: Option<Option<String>>,
    #[serde(rename = "business_country")]
    pub business_country: crate::models::CountryAlpha2,
    /// The business label of merchant for this payment
    #[serde(rename = "business_label")]
    pub business_label: String,
    /// The business_sub_label for this payment
    #[serde(rename = "business_sub_label", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub business_sub_label: Option<Option<String>>,
    /// Allowed Payment Method Types for a given PaymentIntent
    #[serde(rename = "allowed_payment_method_types", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub allowed_payment_method_types: Option<Option<Vec<crate::models::PaymentMethodType>>>,
    #[serde(rename = "ephemeral_key", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub ephemeral_key: Option<Option<Box<crate::models::EphemeralKeyCreateResponse>>>,
    /// If true the payment can be retried with same or different payment method which means the confirm call can be made again.
    #[serde(rename = "manual_retry_allowed", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub manual_retry_allowed: Option<Option<bool>>,
    /// A unique identifier for a payment provided by the connector
    #[serde(rename = "connector_transaction_id", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub connector_transaction_id: Option<Option<String>>,
    /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.
    #[serde(rename = "metadata", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Option<serde_json::Value>>,
    #[serde(rename = "connector_metadata", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub connector_metadata: Option<Option<Box<crate::models::ConnectorMetadata>>>,
    #[serde(rename = "feature_metadata", default, with = "::serde_with::rust::double_option", skip_serializing_if = "Option::is_none")]
    pub feature_metadata: Option<Option<Box<crate::models::FeatureMetadata>>>,
}

impl PaymentsResponse {
    pub fn new(status: crate::models::IntentStatus, amount: i64, currency: crate::models::Currency, payment_method: crate::models::PaymentMethodType, business_country: crate::models::CountryAlpha2, business_label: String) -> PaymentsResponse {
        PaymentsResponse {
            payment_id: None,
            merchant_id: None,
            status,
            amount,
            amount_capturable: None,
            amount_received: None,
            connector: None,
            client_secret: None,
            created: None,
            currency,
            customer_id: None,
            description: None,
            refunds: None,
            disputes: None,
            mandate_id: None,
            mandate_data: None,
            setup_future_usage: None,
            off_session: None,
            capture_on: None,
            capture_method: None,
            payment_method,
            payment_method_data: None,
            payment_token: None,
            shipping: None,
            billing: None,
            order_details: None,
            email: None,
            name: None,
            phone: None,
            return_url: None,
            authentication_type: None,
            statement_descriptor_name: None,
            statement_descriptor_suffix: None,
            next_action: None,
            cancellation_reason: None,
            error_code: None,
            error_message: None,
            payment_experience: None,
            payment_method_type: None,
            connector_label: None,
            business_country,
            business_label,
            business_sub_label: None,
            allowed_payment_method_types: None,
            ephemeral_key: None,
            manual_retry_allowed: None,
            connector_transaction_id: None,
            metadata: None,
            connector_metadata: None,
            feature_metadata: None,
        }
    }
}


