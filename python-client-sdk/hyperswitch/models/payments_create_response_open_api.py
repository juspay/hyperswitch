# coding: utf-8

"""
    Hyperswitch - API Documentation

     ## Get started  Hyperswitch provides a collection of APIs that enable you to process and manage payments. Our APIs accept and return JSON in the HTTP body, and return standard HTTP response codes.  You can consume the APIs directly using your favorite HTTP/REST library.  We have a testing environment referred to \"sandbox\", which you can setup to test API calls without affecting production data. Currently, our sandbox environment is live while our production environment is under development and will be available soon. You can sign up on our Dashboard to get API keys to access Hyperswitch API.  ### Environment  Use the following base URLs when making requests to the APIs:  | Environment   |  Base URL                          | |---------------|------------------------------------| | Sandbox       | <https://sandbox.hyperswitch.io>   | | Production    | <https://api.hyperswitch.io>       |  ## Authentication  When you sign up on our [dashboard](https://app.hyperswitch.io) and create a merchant account, you are given a secret key (also referred as api-key) and a publishable key. You may authenticate all API requests with Hyperswitch server by providing the appropriate key in the request Authorization header.  | Key             |  Description                                                                                  | |-----------------|-----------------------------------------------------------------------------------------------| | api-key         | Private key. Used to authenticate all API requests from your merchant server                  | | publishable key | Unique identifier for your account. Used to authenticate API requests from your app's client  |  Never share your secret api keys. Keep them guarded and secure. 

    The version of the OpenAPI document: 0.1.0
    Contact: hyperswitch@juspay.in
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from hyperswitch.models.address import Address
from hyperswitch.models.authentication_type import AuthenticationType
from hyperswitch.models.browser_information import BrowserInformation
from hyperswitch.models.capture_method import CaptureMethod
from hyperswitch.models.capture_response import CaptureResponse
from hyperswitch.models.card_discovery import CardDiscovery
from hyperswitch.models.connector_charge_response_data import ConnectorChargeResponseData
from hyperswitch.models.connector_metadata import ConnectorMetadata
from hyperswitch.models.country_alpha2 import CountryAlpha2
from hyperswitch.models.currency import Currency
from hyperswitch.models.dispute_response_payments_retrieve import DisputeResponsePaymentsRetrieve
from hyperswitch.models.ephemeral_key_create_response import EphemeralKeyCreateResponse
from hyperswitch.models.external_authentication_details_response import ExternalAuthenticationDetailsResponse
from hyperswitch.models.feature_metadata import FeatureMetadata
from hyperswitch.models.frm_message import FrmMessage
from hyperswitch.models.future_usage import FutureUsage
from hyperswitch.models.incremental_authorization_response import IncrementalAuthorizationResponse
from hyperswitch.models.intent_status import IntentStatus
from hyperswitch.models.mandate_data import MandateData
from hyperswitch.models.next_action_data import NextActionData
from hyperswitch.models.order_details_with_amount import OrderDetailsWithAmount
from hyperswitch.models.payment_attempt_response import PaymentAttemptResponse
from hyperswitch.models.payment_experience import PaymentExperience
from hyperswitch.models.payment_link_response import PaymentLinkResponse
from hyperswitch.models.payment_method import PaymentMethod
from hyperswitch.models.payment_method_data_response_with_billing import PaymentMethodDataResponseWithBilling
from hyperswitch.models.payment_method_status import PaymentMethodStatus
from hyperswitch.models.payment_method_type import PaymentMethodType
from hyperswitch.models.refund_response import RefundResponse
from hyperswitch.models.request_surcharge_details import RequestSurchargeDetails
from typing import Optional, Set
from typing_extensions import Self

class PaymentsCreateResponseOpenApi(BaseModel):
    """
    PaymentsCreateResponseOpenApi
    """ # noqa: E501
    payment_id: Annotated[str, Field(min_length=30, strict=True, max_length=30)] = Field(description="Unique identifier for the payment. This ensures idempotency for multiple payments that have been done by a single merchant.")
    merchant_id: Annotated[str, Field(strict=True, max_length=255)] = Field(description="This is an identifier for the merchant account. This is inferred from the API key provided during the request")
    status: IntentStatus
    amount: StrictInt = Field(description="The payment amount. Amount for the payment in lowest denomination of the currency. (i.e) in cents for USD denomination, in paisa for INR denomination etc.,")
    net_amount: StrictInt = Field(description="The payment net amount. net_amount = amount + surcharge_details.surcharge_amount + surcharge_details.tax_amount + shipping_cost + order_tax_amount, If no surcharge_details, shipping_cost, order_tax_amount, net_amount = amount")
    shipping_cost: Optional[StrictInt] = Field(default=None, description="The shipping cost for the payment.")
    amount_capturable: Annotated[int, Field(strict=True, ge=100)] = Field(description="The maximum amount that could be captured from the payment")
    amount_received: Optional[StrictInt] = Field(default=None, description="The amount which is already captured from the payment, this helps in the cases where merchants can't capture all capturable amount at once.")
    connector: Optional[StrictStr] = Field(default=None, description="The connector used for the payment")
    client_secret: Optional[StrictStr] = Field(default=None, description="It's a token used for client side verification.")
    created: Optional[datetime] = Field(default=None, description="Time when the payment was created")
    currency: Currency
    customer_id: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]] = Field(default=None, description="The identifier for the customer object. If not provided the customer ID will be autogenerated. This field will be deprecated soon. Please refer to `customer.id`")
    description: Optional[StrictStr] = Field(default=None, description="A description of the payment")
    refunds: Optional[List[RefundResponse]] = Field(default=None, description="List of refunds that happened on this intent, as same payment intent can have multiple refund requests depending on the nature of order")
    disputes: Optional[List[DisputeResponsePaymentsRetrieve]] = Field(default=None, description="List of disputes that happened on this intent")
    attempts: Optional[List[PaymentAttemptResponse]] = Field(default=None, description="List of attempts that happened on this intent")
    captures: Optional[List[CaptureResponse]] = Field(default=None, description="List of captures done on latest attempt")
    mandate_id: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="A unique identifier to link the payment to a mandate, can be used instead of payment_method_data, in case of setting up recurring payments")
    mandate_data: Optional[MandateData] = None
    setup_future_usage: Optional[FutureUsage] = None
    off_session: Optional[StrictBool] = Field(default=None, description="Set to true to indicate that the customer is not in your checkout flow during this payment, and therefore is unable to authenticate. This parameter is intended for scenarios where you collect card details and charge them later. This parameter can only be used with confirm=true.")
    capture_method: Optional[CaptureMethod] = None
    payment_method: PaymentMethod
    payment_method_data: Optional[PaymentMethodDataResponseWithBilling] = None
    payment_token: Optional[StrictStr] = Field(default=None, description="Provide a reference to a stored payment method")
    shipping: Optional[Address] = None
    billing: Optional[Address] = None
    order_details: Optional[List[OrderDetailsWithAmount]] = Field(default=None, description="Information about the product , quantity and amount for connectors. (e.g. Klarna)")
    email: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="description: The customer's email address This field will be deprecated soon. Please refer to `customer.email` object")
    name: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="description: The customer's name This field will be deprecated soon. Please refer to `customer.name` object")
    phone: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="The customer's phone number This field will be deprecated soon. Please refer to `customer.phone` object")
    return_url: Optional[StrictStr] = Field(default=None, description="The URL to redirect after the completion of the operation")
    authentication_type: Optional[AuthenticationType] = None
    statement_descriptor_name: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.")
    statement_descriptor_suffix: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 255 characters for the concatenated descriptor.")
    next_action: Optional[NextActionData] = None
    cancellation_reason: Optional[StrictStr] = Field(default=None, description="If the payment was cancelled the reason will be provided here")
    error_code: Optional[StrictStr] = Field(default=None, description="If there was an error while calling the connectors the code is received here")
    error_message: Optional[StrictStr] = Field(default=None, description="If there was an error while calling the connector the error message is received here")
    payment_experience: Optional[PaymentExperience] = None
    payment_method_type: Optional[PaymentMethodType] = None
    connector_label: Optional[StrictStr] = Field(default=None, description="The connector used for this payment along with the country and business details")
    business_country: Optional[CountryAlpha2] = None
    business_label: Optional[StrictStr] = Field(default=None, description="The business label of merchant for this payment")
    business_sub_label: Optional[StrictStr] = Field(default=None, description="The business_sub_label for this payment")
    allowed_payment_method_types: Optional[List[PaymentMethodType]] = Field(default=None, description="Allowed Payment Method Types for a given PaymentIntent")
    ephemeral_key: Optional[EphemeralKeyCreateResponse] = None
    manual_retry_allowed: Optional[StrictBool] = Field(default=None, description="If true the payment can be retried with same or different payment method which means the confirm call can be made again.")
    connector_transaction_id: Optional[StrictStr] = Field(default=None, description="A unique identifier for a payment provided by the connector")
    frm_message: Optional[FrmMessage] = None
    metadata: Optional[Dict[str, Any]] = Field(default=None, description="You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. Metadata is useful for storing additional, structured information on an object.")
    connector_metadata: Optional[ConnectorMetadata] = None
    feature_metadata: Optional[FeatureMetadata] = None
    reference_id: Optional[StrictStr] = Field(default=None, description="reference(Identifier) to the payment at connector side")
    payment_link: Optional[PaymentLinkResponse] = None
    profile_id: Optional[StrictStr] = Field(default=None, description="The business profile that is associated with this payment")
    surcharge_details: Optional[RequestSurchargeDetails] = None
    attempt_count: StrictInt = Field(description="Total number of attempts associated with this payment")
    merchant_decision: Optional[StrictStr] = Field(default=None, description="Denotes the action(approve or reject) taken by merchant in case of manual review. Manual review can occur when the transaction is marked as risky by the frm_processor, payment processor or when there is underpayment/over payment incase of crypto payment")
    merchant_connector_id: Optional[StrictStr] = Field(default=None, description="Identifier of the connector ( merchant connector account ) which was chosen to make the payment")
    incremental_authorization_allowed: Optional[StrictBool] = Field(default=None, description="If true, incremental authorization can be performed on this payment, in case the funds authorized initially fall short.")
    authorization_count: Optional[StrictInt] = Field(default=None, description="Total number of authorizations happened in an incremental_authorization payment")
    incremental_authorizations: Optional[List[IncrementalAuthorizationResponse]] = Field(default=None, description="List of incremental authorizations happened to the payment")
    external_authentication_details: Optional[ExternalAuthenticationDetailsResponse] = None
    external_3ds_authentication_attempted: Optional[StrictBool] = Field(default=None, description="Flag indicating if external 3ds authentication is made or not")
    expires_on: Optional[datetime] = Field(default=None, description="Date Time for expiry of the payment")
    fingerprint: Optional[StrictStr] = Field(default=None, description="Payment Fingerprint, to identify a particular card. It is a 20 character long alphanumeric code.")
    browser_info: Optional[BrowserInformation] = None
    payment_method_id: Optional[StrictStr] = Field(default=None, description="Identifier for Payment Method used for the payment")
    payment_method_status: Optional[PaymentMethodStatus] = None
    updated: Optional[datetime] = Field(default=None, description="Date time at which payment was updated")
    split_payments: Optional[ConnectorChargeResponseData] = None
    frm_metadata: Optional[Dict[str, Any]] = Field(default=None, description="You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long. FRM Metadata is useful for storing additional, structured information on an object related to FRM.")
    extended_authorization_applied: Optional[StrictBool] = Field(default=None, description="flag that indicates if extended authorization is applied on this payment or not")
    capture_before: Optional[datetime] = Field(default=None, description="date and time after which this payment cannot be captured")
    merchant_order_reference_id: Optional[Annotated[str, Field(strict=True, max_length=255)]] = Field(default=None, description="Merchant's identifier for the payment/invoice. This will be sent to the connector if the connector provides support to accept multiple reference ids. In case the connector supports only one reference id, Hyperswitch's Payment ID will be sent as reference.")
    order_tax_amount: Optional[StrictInt] = Field(default=None, description="This Unit struct represents MinorUnit in which core amount works")
    connector_mandate_id: Optional[StrictStr] = Field(default=None, description="Connector Identifier for the payment method")
    card_discovery: Optional[CardDiscovery] = None
    force_3ds_challenge: Optional[StrictBool] = Field(default=None, description="Indicates if 3ds challenge is forced")
    force_3ds_challenge_trigger: Optional[StrictBool] = Field(default=None, description="Indicates if 3ds challenge is triggered")
    issuer_error_code: Optional[StrictStr] = Field(default=None, description="Error code received from the issuer in case of failed payments")
    issuer_error_message: Optional[StrictStr] = Field(default=None, description="Error message received from the issuer in case of failed payments")
    __properties: ClassVar[List[str]] = ["payment_id", "merchant_id", "status", "amount", "net_amount", "shipping_cost", "amount_capturable", "amount_received", "connector", "client_secret", "created", "currency", "customer_id", "description", "refunds", "disputes", "attempts", "captures", "mandate_id", "mandate_data", "setup_future_usage", "off_session", "capture_method", "payment_method", "payment_method_data", "payment_token", "shipping", "billing", "order_details", "email", "name", "phone", "return_url", "authentication_type", "statement_descriptor_name", "statement_descriptor_suffix", "next_action", "cancellation_reason", "error_code", "error_message", "payment_experience", "payment_method_type", "connector_label", "business_country", "business_label", "business_sub_label", "allowed_payment_method_types", "ephemeral_key", "manual_retry_allowed", "connector_transaction_id", "frm_message", "metadata", "connector_metadata", "feature_metadata", "reference_id", "payment_link", "profile_id", "surcharge_details", "attempt_count", "merchant_decision", "merchant_connector_id", "incremental_authorization_allowed", "authorization_count", "incremental_authorizations", "external_authentication_details", "external_3ds_authentication_attempted", "expires_on", "fingerprint", "browser_info", "payment_method_id", "payment_method_status", "updated", "split_payments", "frm_metadata", "extended_authorization_applied", "capture_before", "merchant_order_reference_id", "order_tax_amount", "connector_mandate_id", "card_discovery", "force_3ds_challenge", "force_3ds_challenge_trigger", "issuer_error_code", "issuer_error_message"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PaymentsCreateResponseOpenApi from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in refunds (list)
        _items = []
        if self.refunds:
            for _item_refunds in self.refunds:
                if _item_refunds:
                    _items.append(_item_refunds.to_dict())
            _dict['refunds'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in disputes (list)
        _items = []
        if self.disputes:
            for _item_disputes in self.disputes:
                if _item_disputes:
                    _items.append(_item_disputes.to_dict())
            _dict['disputes'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in attempts (list)
        _items = []
        if self.attempts:
            for _item_attempts in self.attempts:
                if _item_attempts:
                    _items.append(_item_attempts.to_dict())
            _dict['attempts'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in captures (list)
        _items = []
        if self.captures:
            for _item_captures in self.captures:
                if _item_captures:
                    _items.append(_item_captures.to_dict())
            _dict['captures'] = _items
        # override the default output from pydantic by calling `to_dict()` of mandate_data
        if self.mandate_data:
            _dict['mandate_data'] = self.mandate_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payment_method_data
        if self.payment_method_data:
            _dict['payment_method_data'] = self.payment_method_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shipping
        if self.shipping:
            _dict['shipping'] = self.shipping.to_dict()
        # override the default output from pydantic by calling `to_dict()` of billing
        if self.billing:
            _dict['billing'] = self.billing.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in order_details (list)
        _items = []
        if self.order_details:
            for _item_order_details in self.order_details:
                if _item_order_details:
                    _items.append(_item_order_details.to_dict())
            _dict['order_details'] = _items
        # override the default output from pydantic by calling `to_dict()` of next_action
        if self.next_action:
            _dict['next_action'] = self.next_action.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ephemeral_key
        if self.ephemeral_key:
            _dict['ephemeral_key'] = self.ephemeral_key.to_dict()
        # override the default output from pydantic by calling `to_dict()` of frm_message
        if self.frm_message:
            _dict['frm_message'] = self.frm_message.to_dict()
        # override the default output from pydantic by calling `to_dict()` of connector_metadata
        if self.connector_metadata:
            _dict['connector_metadata'] = self.connector_metadata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of feature_metadata
        if self.feature_metadata:
            _dict['feature_metadata'] = self.feature_metadata.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payment_link
        if self.payment_link:
            _dict['payment_link'] = self.payment_link.to_dict()
        # override the default output from pydantic by calling `to_dict()` of surcharge_details
        if self.surcharge_details:
            _dict['surcharge_details'] = self.surcharge_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in incremental_authorizations (list)
        _items = []
        if self.incremental_authorizations:
            for _item_incremental_authorizations in self.incremental_authorizations:
                if _item_incremental_authorizations:
                    _items.append(_item_incremental_authorizations.to_dict())
            _dict['incremental_authorizations'] = _items
        # override the default output from pydantic by calling `to_dict()` of external_authentication_details
        if self.external_authentication_details:
            _dict['external_authentication_details'] = self.external_authentication_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of browser_info
        if self.browser_info:
            _dict['browser_info'] = self.browser_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of split_payments
        if self.split_payments:
            _dict['split_payments'] = self.split_payments.to_dict()
        # set to None if shipping_cost (nullable) is None
        # and model_fields_set contains the field
        if self.shipping_cost is None and "shipping_cost" in self.model_fields_set:
            _dict['shipping_cost'] = None

        # set to None if amount_received (nullable) is None
        # and model_fields_set contains the field
        if self.amount_received is None and "amount_received" in self.model_fields_set:
            _dict['amount_received'] = None

        # set to None if connector (nullable) is None
        # and model_fields_set contains the field
        if self.connector is None and "connector" in self.model_fields_set:
            _dict['connector'] = None

        # set to None if client_secret (nullable) is None
        # and model_fields_set contains the field
        if self.client_secret is None and "client_secret" in self.model_fields_set:
            _dict['client_secret'] = None

        # set to None if created (nullable) is None
        # and model_fields_set contains the field
        if self.created is None and "created" in self.model_fields_set:
            _dict['created'] = None

        # set to None if customer_id (nullable) is None
        # and model_fields_set contains the field
        if self.customer_id is None and "customer_id" in self.model_fields_set:
            _dict['customer_id'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if refunds (nullable) is None
        # and model_fields_set contains the field
        if self.refunds is None and "refunds" in self.model_fields_set:
            _dict['refunds'] = None

        # set to None if disputes (nullable) is None
        # and model_fields_set contains the field
        if self.disputes is None and "disputes" in self.model_fields_set:
            _dict['disputes'] = None

        # set to None if attempts (nullable) is None
        # and model_fields_set contains the field
        if self.attempts is None and "attempts" in self.model_fields_set:
            _dict['attempts'] = None

        # set to None if captures (nullable) is None
        # and model_fields_set contains the field
        if self.captures is None and "captures" in self.model_fields_set:
            _dict['captures'] = None

        # set to None if mandate_id (nullable) is None
        # and model_fields_set contains the field
        if self.mandate_id is None and "mandate_id" in self.model_fields_set:
            _dict['mandate_id'] = None

        # set to None if mandate_data (nullable) is None
        # and model_fields_set contains the field
        if self.mandate_data is None and "mandate_data" in self.model_fields_set:
            _dict['mandate_data'] = None

        # set to None if setup_future_usage (nullable) is None
        # and model_fields_set contains the field
        if self.setup_future_usage is None and "setup_future_usage" in self.model_fields_set:
            _dict['setup_future_usage'] = None

        # set to None if off_session (nullable) is None
        # and model_fields_set contains the field
        if self.off_session is None and "off_session" in self.model_fields_set:
            _dict['off_session'] = None

        # set to None if capture_method (nullable) is None
        # and model_fields_set contains the field
        if self.capture_method is None and "capture_method" in self.model_fields_set:
            _dict['capture_method'] = None

        # set to None if payment_method_data (nullable) is None
        # and model_fields_set contains the field
        if self.payment_method_data is None and "payment_method_data" in self.model_fields_set:
            _dict['payment_method_data'] = None

        # set to None if payment_token (nullable) is None
        # and model_fields_set contains the field
        if self.payment_token is None and "payment_token" in self.model_fields_set:
            _dict['payment_token'] = None

        # set to None if shipping (nullable) is None
        # and model_fields_set contains the field
        if self.shipping is None and "shipping" in self.model_fields_set:
            _dict['shipping'] = None

        # set to None if billing (nullable) is None
        # and model_fields_set contains the field
        if self.billing is None and "billing" in self.model_fields_set:
            _dict['billing'] = None

        # set to None if order_details (nullable) is None
        # and model_fields_set contains the field
        if self.order_details is None and "order_details" in self.model_fields_set:
            _dict['order_details'] = None

        # set to None if email (nullable) is None
        # and model_fields_set contains the field
        if self.email is None and "email" in self.model_fields_set:
            _dict['email'] = None

        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if phone (nullable) is None
        # and model_fields_set contains the field
        if self.phone is None and "phone" in self.model_fields_set:
            _dict['phone'] = None

        # set to None if return_url (nullable) is None
        # and model_fields_set contains the field
        if self.return_url is None and "return_url" in self.model_fields_set:
            _dict['return_url'] = None

        # set to None if authentication_type (nullable) is None
        # and model_fields_set contains the field
        if self.authentication_type is None and "authentication_type" in self.model_fields_set:
            _dict['authentication_type'] = None

        # set to None if statement_descriptor_name (nullable) is None
        # and model_fields_set contains the field
        if self.statement_descriptor_name is None and "statement_descriptor_name" in self.model_fields_set:
            _dict['statement_descriptor_name'] = None

        # set to None if statement_descriptor_suffix (nullable) is None
        # and model_fields_set contains the field
        if self.statement_descriptor_suffix is None and "statement_descriptor_suffix" in self.model_fields_set:
            _dict['statement_descriptor_suffix'] = None

        # set to None if next_action (nullable) is None
        # and model_fields_set contains the field
        if self.next_action is None and "next_action" in self.model_fields_set:
            _dict['next_action'] = None

        # set to None if cancellation_reason (nullable) is None
        # and model_fields_set contains the field
        if self.cancellation_reason is None and "cancellation_reason" in self.model_fields_set:
            _dict['cancellation_reason'] = None

        # set to None if error_code (nullable) is None
        # and model_fields_set contains the field
        if self.error_code is None and "error_code" in self.model_fields_set:
            _dict['error_code'] = None

        # set to None if error_message (nullable) is None
        # and model_fields_set contains the field
        if self.error_message is None and "error_message" in self.model_fields_set:
            _dict['error_message'] = None

        # set to None if payment_experience (nullable) is None
        # and model_fields_set contains the field
        if self.payment_experience is None and "payment_experience" in self.model_fields_set:
            _dict['payment_experience'] = None

        # set to None if payment_method_type (nullable) is None
        # and model_fields_set contains the field
        if self.payment_method_type is None and "payment_method_type" in self.model_fields_set:
            _dict['payment_method_type'] = None

        # set to None if connector_label (nullable) is None
        # and model_fields_set contains the field
        if self.connector_label is None and "connector_label" in self.model_fields_set:
            _dict['connector_label'] = None

        # set to None if business_country (nullable) is None
        # and model_fields_set contains the field
        if self.business_country is None and "business_country" in self.model_fields_set:
            _dict['business_country'] = None

        # set to None if business_label (nullable) is None
        # and model_fields_set contains the field
        if self.business_label is None and "business_label" in self.model_fields_set:
            _dict['business_label'] = None

        # set to None if business_sub_label (nullable) is None
        # and model_fields_set contains the field
        if self.business_sub_label is None and "business_sub_label" in self.model_fields_set:
            _dict['business_sub_label'] = None

        # set to None if allowed_payment_method_types (nullable) is None
        # and model_fields_set contains the field
        if self.allowed_payment_method_types is None and "allowed_payment_method_types" in self.model_fields_set:
            _dict['allowed_payment_method_types'] = None

        # set to None if ephemeral_key (nullable) is None
        # and model_fields_set contains the field
        if self.ephemeral_key is None and "ephemeral_key" in self.model_fields_set:
            _dict['ephemeral_key'] = None

        # set to None if manual_retry_allowed (nullable) is None
        # and model_fields_set contains the field
        if self.manual_retry_allowed is None and "manual_retry_allowed" in self.model_fields_set:
            _dict['manual_retry_allowed'] = None

        # set to None if connector_transaction_id (nullable) is None
        # and model_fields_set contains the field
        if self.connector_transaction_id is None and "connector_transaction_id" in self.model_fields_set:
            _dict['connector_transaction_id'] = None

        # set to None if frm_message (nullable) is None
        # and model_fields_set contains the field
        if self.frm_message is None and "frm_message" in self.model_fields_set:
            _dict['frm_message'] = None

        # set to None if metadata (nullable) is None
        # and model_fields_set contains the field
        if self.metadata is None and "metadata" in self.model_fields_set:
            _dict['metadata'] = None

        # set to None if connector_metadata (nullable) is None
        # and model_fields_set contains the field
        if self.connector_metadata is None and "connector_metadata" in self.model_fields_set:
            _dict['connector_metadata'] = None

        # set to None if feature_metadata (nullable) is None
        # and model_fields_set contains the field
        if self.feature_metadata is None and "feature_metadata" in self.model_fields_set:
            _dict['feature_metadata'] = None

        # set to None if reference_id (nullable) is None
        # and model_fields_set contains the field
        if self.reference_id is None and "reference_id" in self.model_fields_set:
            _dict['reference_id'] = None

        # set to None if payment_link (nullable) is None
        # and model_fields_set contains the field
        if self.payment_link is None and "payment_link" in self.model_fields_set:
            _dict['payment_link'] = None

        # set to None if profile_id (nullable) is None
        # and model_fields_set contains the field
        if self.profile_id is None and "profile_id" in self.model_fields_set:
            _dict['profile_id'] = None

        # set to None if surcharge_details (nullable) is None
        # and model_fields_set contains the field
        if self.surcharge_details is None and "surcharge_details" in self.model_fields_set:
            _dict['surcharge_details'] = None

        # set to None if merchant_decision (nullable) is None
        # and model_fields_set contains the field
        if self.merchant_decision is None and "merchant_decision" in self.model_fields_set:
            _dict['merchant_decision'] = None

        # set to None if merchant_connector_id (nullable) is None
        # and model_fields_set contains the field
        if self.merchant_connector_id is None and "merchant_connector_id" in self.model_fields_set:
            _dict['merchant_connector_id'] = None

        # set to None if incremental_authorization_allowed (nullable) is None
        # and model_fields_set contains the field
        if self.incremental_authorization_allowed is None and "incremental_authorization_allowed" in self.model_fields_set:
            _dict['incremental_authorization_allowed'] = None

        # set to None if authorization_count (nullable) is None
        # and model_fields_set contains the field
        if self.authorization_count is None and "authorization_count" in self.model_fields_set:
            _dict['authorization_count'] = None

        # set to None if incremental_authorizations (nullable) is None
        # and model_fields_set contains the field
        if self.incremental_authorizations is None and "incremental_authorizations" in self.model_fields_set:
            _dict['incremental_authorizations'] = None

        # set to None if external_authentication_details (nullable) is None
        # and model_fields_set contains the field
        if self.external_authentication_details is None and "external_authentication_details" in self.model_fields_set:
            _dict['external_authentication_details'] = None

        # set to None if external_3ds_authentication_attempted (nullable) is None
        # and model_fields_set contains the field
        if self.external_3ds_authentication_attempted is None and "external_3ds_authentication_attempted" in self.model_fields_set:
            _dict['external_3ds_authentication_attempted'] = None

        # set to None if expires_on (nullable) is None
        # and model_fields_set contains the field
        if self.expires_on is None and "expires_on" in self.model_fields_set:
            _dict['expires_on'] = None

        # set to None if fingerprint (nullable) is None
        # and model_fields_set contains the field
        if self.fingerprint is None and "fingerprint" in self.model_fields_set:
            _dict['fingerprint'] = None

        # set to None if browser_info (nullable) is None
        # and model_fields_set contains the field
        if self.browser_info is None and "browser_info" in self.model_fields_set:
            _dict['browser_info'] = None

        # set to None if payment_method_id (nullable) is None
        # and model_fields_set contains the field
        if self.payment_method_id is None and "payment_method_id" in self.model_fields_set:
            _dict['payment_method_id'] = None

        # set to None if payment_method_status (nullable) is None
        # and model_fields_set contains the field
        if self.payment_method_status is None and "payment_method_status" in self.model_fields_set:
            _dict['payment_method_status'] = None

        # set to None if updated (nullable) is None
        # and model_fields_set contains the field
        if self.updated is None and "updated" in self.model_fields_set:
            _dict['updated'] = None

        # set to None if split_payments (nullable) is None
        # and model_fields_set contains the field
        if self.split_payments is None and "split_payments" in self.model_fields_set:
            _dict['split_payments'] = None

        # set to None if frm_metadata (nullable) is None
        # and model_fields_set contains the field
        if self.frm_metadata is None and "frm_metadata" in self.model_fields_set:
            _dict['frm_metadata'] = None

        # set to None if extended_authorization_applied (nullable) is None
        # and model_fields_set contains the field
        if self.extended_authorization_applied is None and "extended_authorization_applied" in self.model_fields_set:
            _dict['extended_authorization_applied'] = None

        # set to None if capture_before (nullable) is None
        # and model_fields_set contains the field
        if self.capture_before is None and "capture_before" in self.model_fields_set:
            _dict['capture_before'] = None

        # set to None if merchant_order_reference_id (nullable) is None
        # and model_fields_set contains the field
        if self.merchant_order_reference_id is None and "merchant_order_reference_id" in self.model_fields_set:
            _dict['merchant_order_reference_id'] = None

        # set to None if order_tax_amount (nullable) is None
        # and model_fields_set contains the field
        if self.order_tax_amount is None and "order_tax_amount" in self.model_fields_set:
            _dict['order_tax_amount'] = None

        # set to None if connector_mandate_id (nullable) is None
        # and model_fields_set contains the field
        if self.connector_mandate_id is None and "connector_mandate_id" in self.model_fields_set:
            _dict['connector_mandate_id'] = None

        # set to None if card_discovery (nullable) is None
        # and model_fields_set contains the field
        if self.card_discovery is None and "card_discovery" in self.model_fields_set:
            _dict['card_discovery'] = None

        # set to None if force_3ds_challenge (nullable) is None
        # and model_fields_set contains the field
        if self.force_3ds_challenge is None and "force_3ds_challenge" in self.model_fields_set:
            _dict['force_3ds_challenge'] = None

        # set to None if force_3ds_challenge_trigger (nullable) is None
        # and model_fields_set contains the field
        if self.force_3ds_challenge_trigger is None and "force_3ds_challenge_trigger" in self.model_fields_set:
            _dict['force_3ds_challenge_trigger'] = None

        # set to None if issuer_error_code (nullable) is None
        # and model_fields_set contains the field
        if self.issuer_error_code is None and "issuer_error_code" in self.model_fields_set:
            _dict['issuer_error_code'] = None

        # set to None if issuer_error_message (nullable) is None
        # and model_fields_set contains the field
        if self.issuer_error_message is None and "issuer_error_message" in self.model_fields_set:
            _dict['issuer_error_message'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PaymentsCreateResponseOpenApi from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "payment_id": obj.get("payment_id"),
            "merchant_id": obj.get("merchant_id"),
            "status": obj.get("status"),
            "amount": obj.get("amount"),
            "net_amount": obj.get("net_amount"),
            "shipping_cost": obj.get("shipping_cost"),
            "amount_capturable": obj.get("amount_capturable"),
            "amount_received": obj.get("amount_received"),
            "connector": obj.get("connector"),
            "client_secret": obj.get("client_secret"),
            "created": obj.get("created"),
            "currency": obj.get("currency"),
            "customer_id": obj.get("customer_id"),
            "description": obj.get("description"),
            "refunds": [RefundResponse.from_dict(_item) for _item in obj["refunds"]] if obj.get("refunds") is not None else None,
            "disputes": [DisputeResponsePaymentsRetrieve.from_dict(_item) for _item in obj["disputes"]] if obj.get("disputes") is not None else None,
            "attempts": [PaymentAttemptResponse.from_dict(_item) for _item in obj["attempts"]] if obj.get("attempts") is not None else None,
            "captures": [CaptureResponse.from_dict(_item) for _item in obj["captures"]] if obj.get("captures") is not None else None,
            "mandate_id": obj.get("mandate_id"),
            "mandate_data": MandateData.from_dict(obj["mandate_data"]) if obj.get("mandate_data") is not None else None,
            "setup_future_usage": obj.get("setup_future_usage"),
            "off_session": obj.get("off_session"),
            "capture_method": obj.get("capture_method"),
            "payment_method": obj.get("payment_method"),
            "payment_method_data": PaymentMethodDataResponseWithBilling.from_dict(obj["payment_method_data"]) if obj.get("payment_method_data") is not None else None,
            "payment_token": obj.get("payment_token"),
            "shipping": Address.from_dict(obj["shipping"]) if obj.get("shipping") is not None else None,
            "billing": Address.from_dict(obj["billing"]) if obj.get("billing") is not None else None,
            "order_details": [OrderDetailsWithAmount.from_dict(_item) for _item in obj["order_details"]] if obj.get("order_details") is not None else None,
            "email": obj.get("email"),
            "name": obj.get("name"),
            "phone": obj.get("phone"),
            "return_url": obj.get("return_url"),
            "authentication_type": obj.get("authentication_type"),
            "statement_descriptor_name": obj.get("statement_descriptor_name"),
            "statement_descriptor_suffix": obj.get("statement_descriptor_suffix"),
            "next_action": NextActionData.from_dict(obj["next_action"]) if obj.get("next_action") is not None else None,
            "cancellation_reason": obj.get("cancellation_reason"),
            "error_code": obj.get("error_code"),
            "error_message": obj.get("error_message"),
            "payment_experience": obj.get("payment_experience"),
            "payment_method_type": obj.get("payment_method_type"),
            "connector_label": obj.get("connector_label"),
            "business_country": obj.get("business_country"),
            "business_label": obj.get("business_label"),
            "business_sub_label": obj.get("business_sub_label"),
            "allowed_payment_method_types": obj.get("allowed_payment_method_types"),
            "ephemeral_key": EphemeralKeyCreateResponse.from_dict(obj["ephemeral_key"]) if obj.get("ephemeral_key") is not None else None,
            "manual_retry_allowed": obj.get("manual_retry_allowed"),
            "connector_transaction_id": obj.get("connector_transaction_id"),
            "frm_message": FrmMessage.from_dict(obj["frm_message"]) if obj.get("frm_message") is not None else None,
            "metadata": obj.get("metadata"),
            "connector_metadata": ConnectorMetadata.from_dict(obj["connector_metadata"]) if obj.get("connector_metadata") is not None else None,
            "feature_metadata": FeatureMetadata.from_dict(obj["feature_metadata"]) if obj.get("feature_metadata") is not None else None,
            "reference_id": obj.get("reference_id"),
            "payment_link": PaymentLinkResponse.from_dict(obj["payment_link"]) if obj.get("payment_link") is not None else None,
            "profile_id": obj.get("profile_id"),
            "surcharge_details": RequestSurchargeDetails.from_dict(obj["surcharge_details"]) if obj.get("surcharge_details") is not None else None,
            "attempt_count": obj.get("attempt_count"),
            "merchant_decision": obj.get("merchant_decision"),
            "merchant_connector_id": obj.get("merchant_connector_id"),
            "incremental_authorization_allowed": obj.get("incremental_authorization_allowed"),
            "authorization_count": obj.get("authorization_count"),
            "incremental_authorizations": [IncrementalAuthorizationResponse.from_dict(_item) for _item in obj["incremental_authorizations"]] if obj.get("incremental_authorizations") is not None else None,
            "external_authentication_details": ExternalAuthenticationDetailsResponse.from_dict(obj["external_authentication_details"]) if obj.get("external_authentication_details") is not None else None,
            "external_3ds_authentication_attempted": obj.get("external_3ds_authentication_attempted"),
            "expires_on": obj.get("expires_on"),
            "fingerprint": obj.get("fingerprint"),
            "browser_info": BrowserInformation.from_dict(obj["browser_info"]) if obj.get("browser_info") is not None else None,
            "payment_method_id": obj.get("payment_method_id"),
            "payment_method_status": obj.get("payment_method_status"),
            "updated": obj.get("updated"),
            "split_payments": ConnectorChargeResponseData.from_dict(obj["split_payments"]) if obj.get("split_payments") is not None else None,
            "frm_metadata": obj.get("frm_metadata"),
            "extended_authorization_applied": obj.get("extended_authorization_applied"),
            "capture_before": obj.get("capture_before"),
            "merchant_order_reference_id": obj.get("merchant_order_reference_id"),
            "order_tax_amount": obj.get("order_tax_amount"),
            "connector_mandate_id": obj.get("connector_mandate_id"),
            "card_discovery": obj.get("card_discovery"),
            "force_3ds_challenge": obj.get("force_3ds_challenge"),
            "force_3ds_challenge_trigger": obj.get("force_3ds_challenge_trigger"),
            "issuer_error_code": obj.get("issuer_error_code"),
            "issuer_error_message": obj.get("issuer_error_message")
        })
        return _obj


