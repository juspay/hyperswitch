name: Create a nightly tag

on:
  workflow_call:
    secrets:
      app_id:
        description: App ID for the GitHub app
        required: true
      app_private_key:
        description: Private key for the GitHub app
        required: true
    outputs:
      tag:
        description: The tag that was created by the workflow
        value: ${{ jobs.create-nightly-tag.outputs.tag }}

env:
  # Allow more retries for network requests in cargo (downloading crates) and
  # rustup (installing toolchains). This should help to reduce flaky CI failures
  # from transient network timeouts or other issues.
  CARGO_NET_RETRY: 10
  RUSTUP_MAX_RETRIES: 10

  # The branch name that this workflow is allowed to run on.
  # If the workflow is run on any other branch, this workflow will fail.
  ALLOWED_BRANCH_NAME: main

jobs:
  create-nightly-tag:
    name: Create a nightly tag
    runs-on: ubuntu-latest

    steps:
      - name: Generate GitHub app token
        id: generate_app_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.app_id }}
          private-key: ${{ secrets.app_private_key }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if the workflow is run on an allowed branch
        shell: bash
        run: |
          if [[ "${{github.ref}}" != "refs/heads/${ALLOWED_BRANCH_NAME}" ]]; then
            echo "::error::This workflow is expected to be run from the '${ALLOWED_BRANCH_NAME}' branch. Current branch: '${{github.ref}}'"
            exit 1
          fi

      - name: Check if the latest commit is a tag
        shell: bash
        run: |
          if [[ -n "$(git tag --points-at HEAD)" ]]; then
            echo "::error::The latest commit on the branch is already a tag"
            exit 1
          fi

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: stable

      - name: Install git-cliff
        uses: baptiste0928/cargo-install@v2.2.0
        with:
          crate: git-cliff
          version: 1.4.0

      - name: Obtain previous and next tag information
        shell: bash
        run: |
          # Calendar versioning format followed: `YYYY.0M.0D.MICRO`
          # - MICRO version number starts from 0 (to allow for multiple tags in a single day)
          # - Hotfixes or patches can be suffixed as `-hotfix1` or `-patch1` after the MICRO version number

          CURRENT_UTC_DATE="$(date --utc '+%04Y.%02m.%02d')"

          # Check if any tags exist on the current branch which contain the current UTC date
          if ! git tag --merged | grep --quiet "${CURRENT_UTC_DATE}"; then
            # Search for date-like tags (no strict checking), sort and obtain previous tag
            PREVIOUS_TAG="$(
              git tag --merged \
                | grep --extended-regexp '[0-9]{4}\.[0-9]{2}\.[0-9]{2}' \
                | sort --version-sort \
                | tail --lines 1
            )"

            # No tags with current date exist, next tag will be just tagged with current date and micro version number 0
            NEXT_MICRO_VERSION_NUMBER='0'
            NEXT_TAG="${CURRENT_UTC_DATE}.${NEXT_MICRO_VERSION_NUMBER}"

          else
            # Some tags exist with current date, find out latest micro version number
            PREVIOUS_TAG="$(
              git tag --merged \
                | grep "${CURRENT_UTC_DATE}" \
                | sort --version-sort \
                | tail --lines 1
            )"
            PREVIOUS_MICRO_VERSION_NUMBER="$(
              echo -n "${PREVIOUS_TAG}" \
                | sed --regexp-extended 's/[0-9]{4}\.[0-9]{2}\.[0-9]{2}(\.([0-9]+))?(-(.+))?/\2/g'
            )"
            #                              ^^^^^^^^  ^^^^^^^^  ^^^^^^^^    ^^^^^^     ^^^^
            #                                YEAR     MONTH      DAY       MICRO      Any suffix, say `hotfix1`
            #
            #                                                              The 2nd capture group contains the micro version number

            if [[ -z "${PREVIOUS_MICRO_VERSION_NUMBER}" ]]; then
              # Micro version number is empty, set next micro version as 1
              NEXT_MICRO_VERSION_NUMBER='1'
            else
              # Increment previous micro version by 1 and set it as next micro version
              NEXT_MICRO_VERSION_NUMBER="$((PREVIOUS_MICRO_VERSION_NUMBER + 1))"
            fi

            NEXT_TAG="${CURRENT_UTC_DATE}.${NEXT_MICRO_VERSION_NUMBER}"
          fi

          echo "PREVIOUS_TAG=${PREVIOUS_TAG}" >> $GITHUB_ENV
          echo "NEXT_TAG=${NEXT_TAG}" >> $GITHUB_ENV

      - name: Generate changelog
        shell: bash
        run: |
          # Generate changelog content and store it in `release-notes.md`
          git-cliff --config '.github/git-cliff-changelog.toml' --strip header --tag "${NEXT_TAG}" "${PREVIOUS_TAG}^.." \
            | sed "/## ${PREVIOUS_TAG}\$/,\$d" \
            | sed '$s/$/\n- - -/' > release-notes.md

          # Append release notes after the specified pattern in `CHANGELOG.md`
          sed --in-place '0,/^- - -/!b; /^- - -/{
              a
              r release-notes.md
            }' CHANGELOG.md
          rm release-notes.md

        # We make use of GitHub API calls to commit and tag the changelog instead of the simpler
        # `git commit`, `git tag` and `git push` commands to have signed commits and tags
      - name: Commit generated changelog and create tag
        shell: bash
        env:
          GH_TOKEN: ${{ steps.generate_app_token.outputs.token }}
        run: |
          HEAD_COMMIT="$(git rev-parse 'HEAD^{commit}')"

          # Create a tree based on the HEAD commit of the current branch and updated changelog file
          TREE_SHA="$(
            gh api \
              --method POST \
              --header 'Accept: application/vnd.github+json' \
              --header 'X-GitHub-Api-Version: 2022-11-28' \
              '/repos/{owner}/{repo}/git/trees' \
              --raw-field base_tree="${HEAD_COMMIT}" \
              --raw-field 'tree[][path]=CHANGELOG.md' \
              --raw-field 'tree[][mode]=100644' \
              --raw-field 'tree[][type]=blob' \
              --field 'tree[][content]=@CHANGELOG.md' \
              --jq '.sha'
          )"

          # Create a commit to point to the above created tree
          NEW_COMMIT_SHA="$(
            gh api \
              --method POST \
              --header 'Accept: application/vnd.github+json' \
              --header 'X-GitHub-Api-Version: 2022-11-28' \
              '/repos/{owner}/{repo}/git/commits' \
              --raw-field "message=chore(version): ${NEXT_TAG}" \
              --raw-field "parents[]=${HEAD_COMMIT}" \
              --raw-field "tree=${TREE_SHA}" \
              --jq '.sha'
          )"

          # Update the current branch to point to the above created commit
          # We disable forced update so that the workflow will fail if the branch has been updated since the workflow started
          # (for example, new commits were pushed to the branch after the workflow execution started).
          gh api \
            --method PATCH \
            --header 'Accept: application/vnd.github+json' \
            --header 'X-GitHub-Api-Version: 2022-11-28' \
            "/repos/{owner}/{repo}/git/refs/heads/${ALLOWED_BRANCH_NAME}" \
            --raw-field "sha=${NEW_COMMIT_SHA}" \
            --field 'force=false'

          # Create a lightweight tag to point to the above created commit
          gh api \
            --method POST \
            --header 'Accept: application/vnd.github+json' \
            --header 'X-GitHub-Api-Version: 2022-11-28' \
            '/repos/{owner}/{repo}/git/refs' \
            --raw-field "ref=refs/tags/${NEXT_TAG}" \
            --raw-field "sha=${NEW_COMMIT_SHA}"

      - name: Set job outputs
        shell: bash
        run: |
          echo "tag=${NEXT_TAG}" >> $GITHUB_OUTPUT
